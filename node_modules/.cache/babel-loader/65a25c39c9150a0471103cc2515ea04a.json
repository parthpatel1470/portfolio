{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.CSSDoodle = factory());\n})(this, function () {\n  'use strict';\n\n  function iterator(input) {\n    let index = 0,\n        col = 1,\n        line = 1;\n    return {\n      curr(n = 0) {\n        return input[index + n];\n      },\n\n      end() {\n        return input.length <= index;\n      },\n\n      info() {\n        return {\n          index,\n          col,\n          line\n        };\n      },\n\n      index(n) {\n        return n === undefined ? index : index = n;\n      },\n\n      next() {\n        let next = input[index++];\n        if (next == '\\n') line++, col = 0;else col++;\n        return next;\n      }\n\n    };\n  } // I'll make it work first\n\n\n  function parse(it) {\n    let word = '',\n        marks = [];\n    let groups = [],\n        result = {};\n\n    while (!it.end()) {\n      let c = it.curr();\n\n      if (c == '(') {\n        marks.push(c);\n        word = '';\n      } else if (c == ')' || c == ',') {\n        if (/^\\-\\-.+/.test(word)) {\n          if (!result.name) {\n            result.name = word;\n          } else {\n            if (!result.alternative) {\n              result.alternative = [];\n            }\n\n            result.alternative.push({\n              name: word\n            });\n          }\n        }\n\n        if (c == ')') {\n          if (marks[marks.length - 1] == '(') {\n            marks.pop();\n          } else {\n            throw new Error('bad match');\n          }\n        }\n\n        if (c == ',') {\n          if (!marks.length) {\n            groups.push(result);\n            result = {};\n          }\n        }\n\n        word = '';\n      } else if (!/\\s/.test(c)) {\n        word += c;\n      }\n\n      it.next();\n    }\n\n    if (marks.length) {\n      return [];\n    }\n\n    if (result.name) {\n      groups.push(result);\n    }\n\n    return groups;\n  }\n\n  function parse_var(input) {\n    input = input.trim();\n    let result = [];\n\n    if (!/^var\\(/.test(input)) {\n      return result;\n    }\n\n    let it = iterator(input);\n\n    try {\n      result = parse(it);\n    } catch (e) {\n      console.error(e && e.message || 'Bad variables.');\n    }\n\n    return result;\n  }\n\n  function make_array(arr) {\n    return Array.isArray(arr) ? arr : [arr];\n  }\n\n  function join(arr, spliter = '\\n') {\n    return (arr || []).join(spliter);\n  }\n\n  function last(arr, n = 1) {\n    return arr[arr.length - n];\n  }\n\n  function first(arr) {\n    return arr[0];\n  }\n\n  function clone(arr) {\n    return JSON.parse(JSON.stringify(arr));\n  }\n\n  function shuffle(arr) {\n    let ret = Array.from ? Array.from(arr) : arr.slice();\n    let m = arr.length;\n\n    while (m) {\n      let i = ~~(Math.random() * m--);\n      let t = ret[m];\n      ret[m] = ret[i];\n      ret[i] = t;\n    }\n\n    return ret;\n  }\n\n  function flat_map(arr, fn) {\n    if (Array.prototype.flatMap) return arr.flatMap(fn);\n    return arr.reduce((acc, x) => acc.concat(fn(x)), []);\n  }\n\n  function remove_empty_values(arr) {\n    return arr.filter(v => v !== undefined && v !== null && String(v).trim().length);\n  }\n\n  const Tokens = {\n    func(name = '') {\n      return {\n        type: 'func',\n        name,\n        arguments: []\n      };\n    },\n\n    argument() {\n      return {\n        type: 'argument',\n        value: []\n      };\n    },\n\n    text(value = '') {\n      return {\n        type: 'text',\n        value\n      };\n    },\n\n    pseudo(selector = '') {\n      return {\n        type: 'pseudo',\n        selector,\n        styles: []\n      };\n    },\n\n    cond(name = '') {\n      return {\n        type: 'cond',\n        name,\n        styles: [],\n        arguments: []\n      };\n    },\n\n    rule(property = '') {\n      return {\n        type: 'rule',\n        property,\n        value: []\n      };\n    },\n\n    keyframes(name = '') {\n      return {\n        type: 'keyframes',\n        name,\n        steps: []\n      };\n    },\n\n    step(name = '') {\n      return {\n        type: 'step',\n        name,\n        styles: []\n      };\n    }\n\n  };\n  const is = {\n    white_space(c) {\n      return /[\\s\\n\\t]/.test(c);\n    },\n\n    line_break(c) {\n      return /\\n/.test(c);\n    },\n\n    number(n) {\n      return !isNaN(n);\n    },\n\n    pair(n) {\n      return ['\"', '(', ')', \"'\"].includes(n);\n    },\n\n    pair_of(c, n) {\n      return {\n        '\"': '\"',\n        \"'\": \"'\",\n        '(': ')'\n      }[c] == n;\n    }\n\n  }; // This should not be in the parser\n  // but I'll leave it here until the rewriting\n\n  const symbols = {\n    'π': Math.PI,\n    '∏': Math.PI\n  };\n\n  function throw_error(msg, {\n    col,\n    line\n  }) {\n    console.error(`(at line ${line}, column ${col}) ${msg}`);\n  }\n\n  function get_text_value(input) {\n    if (input.trim().length) {\n      return is.number(+input) ? +input : input.trim();\n    } else {\n      return input;\n    }\n  }\n\n  function read_until(fn) {\n    return function (it, reset) {\n      let index = it.index();\n      let word = '';\n\n      while (!it.end()) {\n        let c = it.next();\n        if (fn(c)) break;else word += c;\n      }\n\n      if (reset) {\n        it.index(index);\n      }\n\n      return word;\n    };\n  }\n\n  function read_word(it, reset) {\n    let check = c => /[^\\w@]/.test(c);\n\n    return read_until(check)(it, reset);\n  }\n\n  function read_keyframe_name(it) {\n    return read_until(c => /[\\s\\{]/.test(c))(it);\n  }\n\n  function read_line(it, reset) {\n    let check = c => is.line_break(c) || c == '{';\n\n    return read_until(check)(it, reset);\n  }\n\n  function read_step(it, extra) {\n    let c,\n        step = Tokens.step();\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      } else if (!step.name.length) {\n        step.name = read_selector(it);\n      } else {\n        step.styles.push(read_rule(it, extra));\n        if (it.curr() == '}') break;\n      }\n\n      it.next();\n    }\n\n    return step;\n  }\n\n  function read_steps(it, extra) {\n    const steps = [];\n    let c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;else if (is.white_space(c)) {\n        it.next();\n        continue;\n      } else {\n        steps.push(read_step(it, extra));\n      }\n      it.next();\n    }\n\n    return steps;\n  }\n\n  function read_keyframes(it, extra) {\n    let keyframes = Tokens.keyframes(),\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;else if (!keyframes.name.length) {\n        read_word(it);\n        keyframes.name = read_keyframe_name(it);\n\n        if (!keyframes.name.length) {\n          throw_error('missing keyframes name', it.info());\n          break;\n        }\n\n        continue;\n      } else if (c == '{') {\n        it.next();\n        keyframes.steps = read_steps(it, extra);\n        break;\n      }\n      it.next();\n    }\n\n    return keyframes;\n  }\n\n  function read_comments(it, flag = {}) {\n    it.next();\n\n    while (!it.end()) {\n      let c = it.curr();\n\n      if (flag.inline) {\n        if (c == '\\n') break;\n      } else {\n        if ((c = it.curr()) == '*' && it.curr(1) == '/') break;\n      }\n\n      it.next();\n    }\n\n    if (!flag.inline) {\n      it.next();\n      it.next();\n    }\n  }\n\n  function read_property(it) {\n    let prop = '',\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == ':') break;else if (!is.white_space(c)) prop += c;\n      it.next();\n    }\n\n    return prop;\n  }\n\n  function read_arguments(it, composition) {\n    let args = [],\n        group = [],\n        stack = [],\n        arg = '',\n        c;\n\n    while (!it.end()) {\n      c = it.curr();\n\n      if (/[\\('\"`]/.test(c) && it.curr(-1) !== '\\\\') {\n        if (stack.length) {\n          if (c != '(' && c === last(stack)) {\n            stack.pop();\n          } else {\n            stack.push(c);\n          }\n        } else {\n          stack.push(c);\n        }\n\n        arg += c;\n      } else if (c == '@') {\n        if (!group.length) {\n          arg = arg.trimLeft();\n        }\n\n        if (arg.length) {\n          group.push(Tokens.text(arg));\n          arg = '';\n        }\n\n        group.push(read_func(it));\n      } else if (/[,)]/.test(c)) {\n        if (stack.length) {\n          if (c == ')') {\n            stack.pop();\n          }\n\n          arg += c;\n        } else {\n          if (arg.length) {\n            if (!group.length) {\n              group.push(Tokens.text(get_text_value(arg)));\n            } else {\n              group.push(Tokens.text(arg));\n            }\n\n            if (arg.startsWith('±')) {\n              let raw = arg.substr(1);\n              let cloned = clone(group);\n              last(cloned).value = '-' + raw;\n              args.push(normalize_argument(cloned));\n              last(group).value = raw;\n            }\n          }\n\n          args.push(normalize_argument(group));\n          [group, arg] = [[], ''];\n          if (c == ')') break;\n        }\n      } else {\n        if (symbols[c]) {\n          c = symbols[c];\n        }\n\n        arg += c;\n      }\n\n      if (composition && it.curr() == ')' && !stack.length) {\n        if (group.length) {\n          args.push(normalize_argument(group));\n        }\n\n        break;\n      } else {\n        it.next();\n      }\n    }\n\n    return args;\n  }\n\n  function normalize_argument(group) {\n    let result = group.map(arg => {\n      if (arg.type == 'text' && typeof arg.value == 'string') {\n        let value = String(arg.value);\n\n        if (value.includes('`')) {\n          arg.value = value = value.replace(/`/g, '\"');\n        }\n\n        arg.value = value.replace(/\\n+|\\s+/g, ' ');\n      }\n\n      return arg;\n    });\n    let ft = first(result) || {};\n    let ed = last(result) || {};\n\n    if (ft.type == 'text' && ed.type == 'text') {\n      let cf = first(ft.value);\n      let ce = last(ed.value);\n\n      if (typeof ft.value == 'string' && typeof ed.value == 'string') {\n        if (is.pair_of(cf, ce)) {\n          ft.value = ft.value.slice(1);\n          ed.value = ed.value.slice(0, ed.value.length - 1);\n          result.cluster = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function seperate_func_name(name) {\n    let fname = '',\n        extra = '';\n\n    if (/\\D$/.test(name) || Math[name.substr(1)]) {\n      return {\n        fname: name,\n        extra\n      };\n    }\n\n    for (let i = name.length - 1; i >= 0; i--) {\n      let c = name[i];\n\n      if (/[\\d.]/.test(c)) {\n        extra = c + extra;\n      } else {\n        fname = name.substring(0, i + 1);\n        break;\n      }\n    }\n\n    return {\n      fname,\n      extra\n    };\n  }\n\n  function read_func(it) {\n    let func = Tokens.func();\n    let name = '@',\n        c;\n    let has_argument = false;\n    it.next();\n\n    while (!it.end()) {\n      c = it.curr();\n      let composition = c == '.' && it.curr(1) == '@';\n      let next = it.curr(1);\n\n      if (c == '(' || composition) {\n        has_argument = true;\n        it.next();\n        func.arguments = read_arguments(it, composition);\n        break;\n      } else if (!has_argument && next !== '(' && !/[0-9a-zA-Z_\\-.]/.test(next)) {\n        name += c;\n        break;\n      } else {\n        name += c;\n      }\n\n      it.next();\n    }\n\n    let {\n      fname,\n      extra\n    } = seperate_func_name(name);\n    func.name = fname;\n\n    if (extra.length) {\n      func.arguments.unshift([{\n        type: 'text',\n        value: extra\n      }]);\n    }\n\n    func.position = it.info().index;\n    return func;\n  }\n\n  function read_value(it) {\n    let text = Tokens.text(),\n        idx = 0,\n        skip = true,\n        c;\n    const value = [],\n          stack = [];\n    value[idx] = [];\n\n    while (!it.end()) {\n      c = it.curr();\n\n      if (skip && is.white_space(c)) {\n        it.next();\n        continue;\n      } else {\n        skip = false;\n      }\n\n      if (c == '\\n' && !is.white_space(it.curr(-1))) {\n        text.value += ' ';\n      } else if (c == ',' && !stack.length) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n\n        value[++idx] = [];\n        skip = true;\n      } else if (/[;}]/.test(c)) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n\n        break;\n      } else if (c == '@') {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n\n        value[idx].push(read_func(it));\n      } else if (!is.white_space(c) || !is.white_space(it.curr(-1))) {\n        if (c == '(') stack.push(c);\n        if (c == ')') stack.pop();\n\n        if (symbols[c]) {\n          c = symbols[c];\n        }\n\n        text.value += c;\n      }\n\n      it.next();\n    }\n\n    if (text.value.length) {\n      value[idx].push(text);\n    }\n\n    return value;\n  }\n\n  function read_selector(it) {\n    let selector = '',\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '{') break;else if (!is.white_space(c)) {\n        selector += c;\n      }\n      it.next();\n    }\n\n    return selector;\n  }\n\n  function read_cond_selector(it) {\n    let selector = {\n      name: '',\n      arguments: []\n    },\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '(') {\n        it.next();\n        selector.arguments = read_arguments(it);\n      } else if (/[){]/.test(c)) break;else if (!is.white_space(c)) selector.name += c;\n\n      it.next();\n    }\n\n    return selector;\n  }\n\n  function read_pseudo(it, extra) {\n    let pseudo = Tokens.pseudo(),\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      } else if (!pseudo.selector) {\n        pseudo.selector = read_selector(it);\n      } else {\n        let rule = read_rule(it, extra);\n\n        if (rule.property == '@use') {\n          pseudo.styles = pseudo.styles.concat(rule.value);\n        } else {\n          pseudo.styles.push(rule);\n        }\n\n        if (it.curr() == '}') break;\n      }\n\n      it.next();\n    }\n\n    return pseudo;\n  }\n\n  function read_rule(it, extra) {\n    let rule = Tokens.rule(),\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == ';') break;else if (!rule.property.length) {\n        rule.property = read_property(it);\n\n        if (rule.property == '@use') {\n          rule.value = read_var(it, extra);\n          break;\n        }\n      } else {\n        rule.value = read_value(it);\n        break;\n      }\n      it.next();\n    }\n\n    return rule;\n  }\n\n  function read_cond(it, extra) {\n    let cond = Tokens.cond(),\n        c;\n\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;else if (!cond.name.length) {\n        Object.assign(cond, read_cond_selector(it));\n      } else if (c == ':') {\n        let pseudo = read_pseudo(it);\n        if (pseudo.selector) cond.styles.push(pseudo);\n      } else if (c == '@' && !read_line(it, true).includes(':')) {\n        cond.styles.push(read_cond(it));\n      } else if (!is.white_space(c)) {\n        let rule = read_rule(it, extra);\n        if (rule.property) cond.styles.push(rule);\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n\n    return cond;\n  }\n\n  function read_property_value(extra, name) {\n    let rule = '';\n\n    if (extra && extra.get_custom_property_value) {\n      rule = extra.get_custom_property_value(name);\n    }\n\n    return rule;\n  }\n\n  function evaluate_value(values, extra) {\n    values.forEach && values.forEach(v => {\n      if (v.type == 'text' && v.value) {\n        let vars = parse_var(v.value);\n        v.value = vars.reduce((ret, p) => {\n          let rule = '',\n              other = '',\n              parsed;\n          rule = read_property_value(extra, p.name);\n\n          if (!rule && p.alternative) {\n            p.alternative.every(n => {\n              other = read_property_value(extra, n.name);\n\n              if (other) {\n                rule = other;\n                return false;\n              }\n            });\n          }\n\n          try {\n            parsed = parse$1(rule, extra);\n          } catch (e) {}\n\n          if (parsed) {\n            ret.push.apply(ret, parsed);\n          }\n\n          return ret;\n        }, []);\n      }\n\n      if (v.type == 'func' && v.arguments) {\n        v.arguments.forEach(arg => {\n          evaluate_value(arg, extra);\n        });\n      }\n    });\n  }\n\n  function read_var(it, extra) {\n    it.next();\n    let groups = read_value(it) || [];\n    return groups.reduce((ret, group) => {\n      evaluate_value(group, extra);\n      let [token] = group;\n\n      if (token.value && token.value.length) {\n        ret.push(...token.value);\n      }\n\n      return ret;\n    }, []);\n  }\n\n  function parse$1(input, extra) {\n    const it = iterator(input);\n    const Tokens = [];\n\n    while (!it.end()) {\n      let c = it.curr();\n\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      } else if (c == '/' && it.curr(1) == '*') {\n        read_comments(it);\n      } else if (c == '/' && it.curr(1) == '/') {\n        read_comments(it, {\n          inline: true\n        });\n      } else if (c == ':') {\n        let pseudo = read_pseudo(it, extra);\n        if (pseudo.selector) Tokens.push(pseudo);\n      } else if (c == '@' && read_word(it, true) === '@keyframes') {\n        let keyframes = read_keyframes(it, extra);\n        Tokens.push(keyframes);\n      } else if (c == '@' && !read_line(it, true).includes(':')) {\n        let cond = read_cond(it, extra);\n        if (cond.name.length) Tokens.push(cond);\n      } else if (!is.white_space(c)) {\n        let rule = read_rule(it, extra);\n        if (rule.property) Tokens.push(rule);\n      }\n\n      it.next();\n    }\n\n    return Tokens;\n  }\n\n  function clamp(num, min, max) {\n    return Math.max(min, Math.min(max, num));\n  }\n\n  function maybe(cond, value) {\n    if (!cond) return '';\n    return typeof value === 'function' ? value() : value;\n  }\n\n  function range(start, stop, step) {\n    let count = 0,\n        old = start;\n\n    let initial = n => n > 0 && n < 1 ? .1 : 1;\n\n    let length = arguments.length;\n    if (length == 1) [start, stop] = [initial(start), start];\n    if (length < 3) step = initial(start);\n    let range = [];\n\n    while (step >= 0 && start <= stop || step < 0 && start > stop) {\n      range.push(start);\n      start += step;\n      if (count++ >= 1000) break;\n    }\n\n    if (!range.length) range.push(old);\n    return range;\n  }\n\n  function alias_for(obj, names) {\n    Object.keys(names).forEach(n => {\n      obj[n] = obj[names[n]];\n    });\n    return obj;\n  }\n\n  function is_letter(c) {\n    return /^[a-zA-Z]$/.test(c);\n  }\n\n  function lazy(fn) {\n    let wrap = () => fn;\n\n    wrap.lazy = true;\n    return wrap;\n  }\n\n  function sequence(count, fn) {\n    let ret = [];\n\n    for (let i = 0; i < count; ++i) {\n      ret.push(fn(i));\n    }\n\n    return ret;\n  }\n\n  function cell_id(x, y, z) {\n    return 'cell-' + x + '-' + y + '-' + z;\n  }\n\n  function get_value(input) {\n    while (input && input.value) {\n      return get_value(input.value);\n    }\n\n    return input || '';\n  }\n\n  const [min, max, total] = [1, 64, 64 * 64];\n\n  function parse_grid(size) {\n    let [x, y, z] = (size + '').replace(/\\s+/g, '').replace(/[,，xX]+/g, 'x').split('x').map(Number);\n    const max_xy = x == 1 || y == 1 ? total : max;\n    const max_z = x == 1 && y == 1 ? total : min;\n    const ret = {\n      x: clamp(x || min, 1, max_xy),\n      y: clamp(y || x || min, 1, max_xy),\n      z: clamp(z || min, 1, max_z)\n    };\n    return Object.assign({}, ret, {\n      count: ret.x * ret.y * ret.z\n    });\n  }\n\n  function create_svg_url(svg, id) {\n    if (id) {\n      let blob = new Blob([svg], {\n        type: 'image/svg+xml'\n      });\n      let url = URL.createObjectURL(blob);\n      return `url(${url}#${id})`;\n    } else {\n      let encoded = encodeURIComponent(svg);\n      return `url(\"data:image/svg+xml;utf8,${encoded}\")`;\n    }\n  }\n\n  function normalize_svg(input) {\n    const xmlns = 'xmlns=\"http://www.w3.org/2000/svg\"';\n\n    if (!input.includes('<svg')) {\n      input = `<svg ${xmlns}>${input}</svg>`;\n    }\n\n    if (!input.includes('xmlns')) {\n      input = input.replace(/<svg([\\s>])/, `<svg ${xmlns}$1`);\n    }\n\n    return input;\n  }\n\n  function lerp(start, end, t) {\n    return start * (1 - t) + end * t;\n  }\n\n  function rand(start = 0, end = start) {\n    if (arguments.length == 1) {\n      if (start == 1) start = 0;else if (start < 1) start /= 10;else start = 1;\n    }\n\n    return lerp(start, end, Math.random());\n  }\n\n  function pick(...items) {\n    let args = items.reduce((acc, n) => acc.concat(n), []);\n    return args[~~(Math.random() * args.length)];\n  }\n\n  function unique_id(prefix = '') {\n    return prefix + Math.random().toString(32).substr(2);\n  }\n\n  function by_unit(fn) {\n    return (...args) => {\n      let unit = get_unit(args);\n      return restore(fn, unit).apply(null, args);\n    };\n  }\n\n  function restore(fn, unit) {\n    return (...args) => {\n      args = args.map(str => Number(String(str).replace(/\\D+$/g, '')));\n      let result = fn.apply(null, args);\n\n      if (!unit.length) {\n        return result;\n      }\n\n      if (Array.isArray(result)) {\n        return result.map(n => n + unit);\n      }\n\n      return result + unit;\n    };\n  }\n\n  function get_unit(values) {\n    let unit = '';\n    values.some(str => {\n      let input = String(str).trim();\n      if (!input) return '';\n      let matched = input.match(/\\d(\\D+)$/);\n      return unit = matched ? matched[1] : '';\n    });\n    return unit;\n  }\n\n  function by_charcode(fn) {\n    return (...args) => {\n      let codes = args.map(n => String(n).charCodeAt(0));\n      let result = fn.apply(null, codes);\n      return Array.isArray(result) ? result.map(n => String.fromCharCode(n)) : String.fromCharCode(result);\n    };\n  }\n  /**\n   * Based on the Shunting-yard algorithm.\n   */\n\n\n  function calc(input) {\n    const expr = infix_to_postfix(input),\n          stack = [];\n\n    while (expr.length) {\n      let top = expr.shift();\n      if (/\\d+/.test(top)) stack.push(top);else {\n        let right = stack.pop();\n        let left = stack.pop();\n        stack.push(compute(top, Number(left), Number(right)));\n      }\n    }\n\n    return stack[0];\n  }\n\n  const operator = {\n    '*': 3,\n    '/': 3,\n    '%': 3,\n    '+': 2,\n    '-': 2,\n    '(': 1,\n    ')': 1\n  };\n\n  function get_tokens(input) {\n    let expr = String(input);\n    let tokens = [],\n        num = '';\n\n    for (let i = 0; i < expr.length; ++i) {\n      let c = expr[i];\n\n      if (operator[c]) {\n        if (c == '-' && expr[i - 1] == 'e') {\n          num += c;\n        } else if (!tokens.length && !num.length && /[+-]/.test(c)) {\n          num += c;\n        } else {\n          let {\n            type,\n            value\n          } = last(tokens) || {};\n\n          if (type == 'operator' && !num.length && /[^()]/.test(c) && /[^()]/.test(value)) {\n            num += c;\n          } else {\n            if (num.length) {\n              tokens.push({\n                type: 'number',\n                value: num\n              });\n              num = '';\n            }\n\n            tokens.push({\n              type: 'operator',\n              value: c\n            });\n          }\n        }\n      } else if (/\\S/.test(c)) {\n        num += c;\n      }\n    }\n\n    if (num.length) {\n      tokens.push({\n        type: 'number',\n        value: num\n      });\n    }\n\n    return tokens;\n  }\n\n  function infix_to_postfix(input) {\n    let tokens = get_tokens(input);\n    const op_stack = [],\n          expr = [];\n\n    for (let i = 0; i < tokens.length; ++i) {\n      let {\n        type,\n        value\n      } = tokens[i];\n\n      if (type == 'number') {\n        expr.push(value);\n      } else if (type == 'operator') {\n        if (value == '(') {\n          op_stack.push(value);\n        } else if (value == ')') {\n          while (op_stack.length && last(op_stack) != '(') {\n            expr.push(op_stack.pop());\n          }\n\n          op_stack.pop();\n        } else {\n          while (op_stack.length && operator[last(op_stack)] >= operator[value]) {\n            let op = op_stack.pop();\n            if (!/[()]/.test(op)) expr.push(op);\n          }\n\n          op_stack.push(value);\n        }\n      }\n    }\n\n    while (op_stack.length) {\n      expr.push(op_stack.pop());\n    }\n\n    return expr;\n  }\n\n  function compute(op, a, b) {\n    switch (op) {\n      case '+':\n        return a + b;\n\n      case '-':\n        return a - b;\n\n      case '*':\n        return a * b;\n\n      case '/':\n        return a / b;\n\n      case '%':\n        return a % b;\n    }\n  }\n\n  const store = {};\n\n  function memo$1(prefix, fn) {\n    return (...args) => {\n      let key = prefix + args.join('-');\n      if (store[key]) return store[key];\n      return store[key] = fn.apply(null, args);\n    };\n  }\n\n  function expand(fn) {\n    return (...args) => fn.apply(null, flat_map(args, n => String(n).startsWith('[') ? build_range(n) : n));\n  }\n\n  function Type(type, value) {\n    return {\n      type,\n      value\n    };\n  }\n\n  function get_tokens$1(input) {\n    let expr = String(input);\n    let tokens = [],\n        stack = [];\n\n    if (!expr.startsWith('[') || !expr.endsWith(']')) {\n      return tokens;\n    }\n\n    for (let i = 1; i < expr.length - 1; ++i) {\n      let c = expr[i];\n\n      if (c == '-' && expr[i - 1] == '-') {\n        continue;\n      }\n\n      if (c == '-') {\n        stack.push(c);\n        continue;\n      }\n\n      if (last(stack) == '-') {\n        stack.pop();\n        let from = stack.pop();\n        tokens.push(from ? Type('range', [from, c]) : Type('char', c));\n        continue;\n      }\n\n      if (stack.length) {\n        tokens.push(Type('char', stack.pop()));\n      }\n\n      stack.push(c);\n    }\n\n    if (stack.length) {\n      tokens.push(Type('char', stack.pop()));\n    }\n\n    return tokens;\n  }\n\n  const build_range = memo$1('build_range', input => {\n    let tokens = get_tokens$1(input);\n    return flat_map(tokens, ({\n      type,\n      value\n    }) => {\n      if (type == 'char') return value;\n      let [from, to] = value;\n      let reverse = false;\n\n      if (from > to) {\n        [from, to] = [to, from];\n        reverse = true;\n      }\n\n      let result = by_charcode(range)(from, to);\n      if (reverse) result.reverse();\n      return result;\n    });\n  });\n\n  class Node {\n    constructor(data) {\n      this.prev = this.next = null;\n      this.data = data;\n    }\n\n  }\n\n  class Stack {\n    constructor(limit = 20) {\n      this._limit = limit;\n      this._size = 0;\n    }\n\n    push(data) {\n      if (this._size >= this._limit) {\n        this.root = this.root.next;\n        this.root.prev = null;\n      }\n\n      let node = new Node(data);\n\n      if (!this.root) {\n        this.root = this.tail = node;\n      } else {\n        node.prev = this.tail;\n        this.tail.next = node;\n        this.tail = node;\n      }\n\n      this._size++;\n    }\n\n    last(n = 1) {\n      let node = this.tail;\n\n      while (--n) {\n        if (!node.prev) break;\n        node = node.prev;\n      }\n\n      return node.data;\n    }\n\n  }\n\n  const {\n    cos,\n    sin,\n    sqrt,\n    pow,\n    PI\n  } = Math;\n  const DEG = PI / 180;\n\n  function polygon(option, fn) {\n    if (typeof arguments[0] == 'function') {\n      fn = option;\n      option = {};\n    }\n\n    if (!fn) {\n      fn = t => [cos(t), sin(t)];\n    }\n\n    let split = option.split || 120;\n    let scale = option.scale || 1;\n    let start = DEG * (option.start || 0);\n    let deg = option.deg ? option.deg * DEG : PI / (split / 2);\n    let points = [];\n\n    for (let i = 0; i < split; ++i) {\n      let t = start + deg * i;\n      let [x, y] = fn(t);\n      points.push(x * 50 * scale + 50 + '% ' + (y * 50 * scale + 50 + '%'));\n    }\n\n    return option.type ? `polygon(${option.type}, ${points.join(',')})` : `polygon(${points.join(',')})`;\n  }\n\n  function rotate(x, y, deg) {\n    let rad = DEG * deg;\n    return [x * cos(rad) - y * sin(rad), y * cos(rad) + x * sin(rad)];\n  }\n\n  const shapes = {\n    circle() {\n      return 'circle(49%)';\n    },\n\n    triangle() {\n      return polygon({\n        split: 3,\n        start: -90\n      }, t => [cos(t) * 1.1, sin(t) * 1.1 + .2]);\n    },\n\n    rhombus() {\n      return polygon({\n        split: 4\n      });\n    },\n\n    pentagon() {\n      return polygon({\n        split: 5,\n        start: 54\n      });\n    },\n\n    hexgon() {\n      return polygon({\n        split: 6,\n        start: 30\n      });\n    },\n\n    hexagon() {\n      return polygon({\n        split: 6,\n        start: 30\n      });\n    },\n\n    heptagon() {\n      return polygon({\n        split: 7,\n        start: -90\n      });\n    },\n\n    octagon() {\n      return polygon({\n        split: 8,\n        start: 22.5\n      });\n    },\n\n    star() {\n      return polygon({\n        split: 5,\n        start: 54,\n        deg: 144\n      });\n    },\n\n    diamond() {\n      return 'polygon(50% 5%, 80% 50%, 50% 95%, 20% 50%)';\n    },\n\n    cross() {\n      return `polygon(\n      5% 35%,  35% 35%, 35% 5%,  65% 5%,\n      65% 35%, 95% 35%, 95% 65%, 65% 65%,\n      65% 95%, 35% 95%, 35% 65%, 5% 65%\n    )`;\n    },\n\n    clover(k = 3) {\n      k = clamp(k, 3, 5);\n      if (k == 4) k = 2;\n      return polygon({\n        split: 240\n      }, t => {\n        let x = cos(k * t) * cos(t);\n        let y = cos(k * t) * sin(t);\n        if (k == 3) x -= .2;\n\n        if (k == 2) {\n          x /= 1.1;\n          y /= 1.1;\n        }\n\n        return [x, y];\n      });\n    },\n\n    hypocycloid(k = 3) {\n      k = clamp(k, 3, 6);\n      let m = 1 - k;\n      return polygon({\n        scale: 1 / k\n      }, t => {\n        let x = m * cos(t) + cos(m * (t - PI));\n        let y = m * sin(t) + sin(m * (t - PI));\n\n        if (k == 3) {\n          x = x * 1.1 - .6;\n          y = y * 1.1;\n        }\n\n        return [x, y];\n      });\n    },\n\n    astroid() {\n      return shapes.hypocycloid(4);\n    },\n\n    infinity() {\n      return polygon(t => {\n        let a = .7 * sqrt(2) * cos(t);\n        let b = pow(sin(t), 2) + 1;\n        return [a / b, a * sin(t) / b];\n      });\n    },\n\n    heart() {\n      return polygon(t => {\n        let x = .75 * pow(sin(t), 3);\n        let y = cos(1 * t) * (13 / 18) - cos(2 * t) * (5 / 18) - cos(3 * t) / 18 - cos(4 * t) / 18;\n        return rotate(x * 1.2, (y + .2) * 1.1, 180);\n      });\n    },\n\n    bean() {\n      return polygon(t => {\n        let [a, b] = [pow(sin(t), 3), pow(cos(t), 3)];\n        return rotate((a + b) * cos(t) * 1.3 - .45, (a + b) * sin(t) * 1.3 - .45, -90);\n      });\n    },\n\n    bicorn() {\n      return polygon(t => rotate(cos(t), pow(sin(t), 2) / (2 + sin(t)) - .5, 180));\n    },\n\n    drop() {\n      return polygon(t => rotate(sin(t), (1 + sin(t)) * cos(t) / 1.4, 90));\n    },\n\n    pear() {\n      return polygon(t => [sin(t), (1 + sin(t)) * cos(t) / 1.4]);\n    },\n\n    fish() {\n      return polygon(t => [cos(t) - pow(sin(t), 2) / sqrt(2), sin(2 * t) / 2]);\n    },\n\n    whale() {\n      return polygon({\n        split: 240\n      }, t => {\n        let r = 3.4 * (pow(sin(t), 2) - .5) * cos(t);\n        return rotate(cos(t) * r + .75, sin(t) * r * 1.2, 180);\n      });\n    },\n\n    bud(n = 3) {\n      n = clamp(n, 3, 10);\n      return polygon({\n        split: 240\n      }, t => [(1 + .2 * cos(n * t)) * cos(t) * .8, (1 + .2 * cos(n * t)) * sin(t) * .8]);\n    },\n\n    alien(...args) {\n      let [a = 1, b = 1, c = 1, d = 1, e = 1] = args.map(n => clamp(n, 1, 9));\n      return polygon({\n        split: 480,\n        type: 'evenodd'\n      }, t => [(cos(t * a) + cos(t * c) + cos(t * e)) * .31, (sin(t * b) + sin(t * d) + sin(t)) * .31]);\n    }\n\n  };\n\n  function is_seperator(c, no_space) {\n    if (no_space) return /[,，]/.test(c);else return /[,，\\s]/.test(c);\n  }\n\n  function skip_seperator(it, no_space) {\n    while (!it.end()) {\n      if (!is_seperator(it.curr(1), no_space)) break;else it.next();\n    }\n  }\n\n  function parse$2(input, no_space = false) {\n    const it = iterator(input);\n    const result = [],\n          stack = [];\n    let group = '';\n\n    while (!it.end()) {\n      let c = it.curr();\n      if (c === undefined) break;\n\n      if (c == '(') {\n        group += c;\n        stack.push(c);\n      } else if (c == ')') {\n        group += c;\n\n        if (stack.length) {\n          stack.pop();\n        }\n      } else if (stack.length) {\n        group += c;\n      } else if (is_seperator(c, no_space)) {\n        result.push(group);\n        group = '';\n        skip_seperator(it, no_space);\n      } else {\n        group += c;\n      }\n\n      it.next();\n    }\n\n    if (group) {\n      result.push(group);\n    }\n\n    return result;\n  }\n\n  const Expose = {\n    index({\n      count\n    }) {\n      return _ => count;\n    },\n\n    row({\n      x\n    }) {\n      return _ => x;\n    },\n\n    col({\n      y\n    }) {\n      return _ => y;\n    },\n\n    depth({\n      z\n    }) {\n      return _ => z;\n    },\n\n    size({\n      grid\n    }) {\n      return _ => grid.count;\n    },\n\n    ['size-row']({\n      grid\n    }) {\n      return _ => grid.x;\n    },\n\n    ['size-col']({\n      grid\n    }) {\n      return _ => grid.y;\n    },\n\n    ['size-depth']({\n      grid\n    }) {\n      return _ => grid.z;\n    },\n\n    id({\n      x,\n      y,\n      z\n    }) {\n      return _ => cell_id(x, y, z);\n    },\n\n    n({\n      extra\n    }) {\n      return _ => {\n        return extra ? extra[0] : '@n';\n      };\n    },\n\n    N({\n      extra\n    }) {\n      return _ => {\n        return extra ? extra[1] : '@N';\n      };\n    },\n\n    repeat: make_sequence(''),\n    multiple: make_sequence(','),\n    ['multiple-with-space']: make_sequence(' '),\n\n    pick({\n      context\n    }) {\n      return expand((...args) => {\n        return push_stack(context, 'last_pick', pick(args));\n      });\n    },\n\n    ['pick-n']({\n      context,\n      extra,\n      position\n    }) {\n      let counter = 'pn-counter' + position;\n      return expand((...args) => {\n        if (!context[counter]) context[counter] = 0;\n        context[counter] += 1;\n        let max = args.length;\n        let [idx] = extra || [];\n        let pos = ((idx === undefined ? context[counter] : idx) - 1) % max;\n        let value = args[pos];\n        return push_stack(context, 'last_pick', value);\n      });\n    },\n\n    ['pick-d']({\n      context,\n      extra,\n      position\n    }) {\n      let counter = 'pd-counter' + position;\n      let values = 'pd-values' + position;\n      return expand((...args) => {\n        if (!context[counter]) context[counter] = 0;\n        context[counter] += 1;\n\n        if (!context[values]) {\n          context[values] = shuffle(args);\n        }\n\n        let max = args.length;\n        let [idx] = extra || [];\n        let pos = ((idx === undefined ? context[counter] : idx) - 1) % max;\n        let value = context[values][pos];\n        return push_stack(context, 'last_pick', value);\n      });\n    },\n\n    ['last-pick']({\n      context\n    }) {\n      return (n = 1) => {\n        let stack = context.last_pick;\n        return stack ? stack.last(n) : '';\n      };\n    },\n\n    rand({\n      context\n    }) {\n      return (...args) => {\n        let transform_type = args.every(is_letter) ? by_charcode : by_unit;\n        let value = transform_type(rand).apply(null, args);\n        return push_stack(context, 'last_rand', value);\n      };\n    },\n\n    ['rand-int']({\n      context\n    }) {\n      return (...args) => {\n        let transform_type = args.every(is_letter) ? by_charcode : by_unit;\n        let value = parseInt(transform_type(rand).apply(null, args));\n        return push_stack(context, 'last_rand', value);\n      };\n    },\n\n    ['last-rand']({\n      context\n    }) {\n      return (n = 1) => {\n        let stack = context.last_rand;\n        return stack ? stack.last(n) : '';\n      };\n    },\n\n    stripe() {\n      return (...input) => {\n        let colors = input.map(get_value);\n        let max = colors.length;\n        let default_count = 0;\n        let custom_sizes = [];\n        let prev;\n\n        if (!max) {\n          return '';\n        }\n\n        colors.forEach(step => {\n          let [_, size] = parse$2(step);\n          if (size !== undefined) custom_sizes.push(size);else default_count += 1;\n        });\n        let default_size = custom_sizes.length ? `(100% - ${custom_sizes.join(' - ')}) / ${default_count}` : `100% / ${max}`;\n        return colors.map((step, i) => {\n          if (custom_sizes.length) {\n            let [color, size] = parse$2(step);\n            let prefix = prev ? prev + ' + ' : '';\n            prev = prefix + (size !== undefined ? size : default_size);\n            return `${color} 0 calc(${prev})`;\n          }\n\n          return `${step} 0 ${100 / max * (i + 1)}%`;\n        }).join(',');\n      };\n    },\n\n    calc() {\n      return value => calc(get_value(value));\n    },\n\n    hex() {\n      return value => parseInt(get_value(value)).toString(16);\n    },\n\n    svg: lazy(input => {\n      if (input === undefined) return '';\n      let svg = normalize_svg(get_value(input()).trim());\n      return create_svg_url(svg);\n    }),\n    ['svg-filter']: lazy(input => {\n      if (input === undefined) return '';\n      let id = unique_id('filter-');\n      let svg = normalize_svg(get_value(input()).trim()).replace(/<filter([\\s>])/, `<filter id=\"${id}\"$1`);\n      return create_svg_url(svg, id);\n    }),\n\n    var() {\n      return value => `var(${get_value(value)})`;\n    },\n\n    shape() {\n      return memo('shape-function', (type = '', ...args) => {\n        type = type.trim();\n\n        if (typeof shapes[type] === 'function') {\n          return shapes[type](args);\n        }\n\n        return '';\n      });\n    }\n\n  };\n\n  function make_sequence(c) {\n    return lazy((n, action) => {\n      if (!action || !n) return '';\n      let count = clamp(get_value(n()), 0, 65536);\n      return sequence(count, i => get_value(action(i + 1, count))).join(c);\n    });\n  }\n\n  function push_stack(context, name, value) {\n    if (!context[name]) context[name] = new Stack();\n    context[name].push(value);\n    return value;\n  }\n\n  var Func = alias_for(Expose, {\n    'm': 'multiple',\n    'ms': 'multiple-with-space',\n    'r': 'rand',\n    'ri': 'rand-int',\n    'lr': 'last-rand',\n    'p': 'pick',\n    'pn': 'pick-n',\n    'pd': 'pick-d',\n    'lp': 'last-pick',\n    'rep': 'repeat',\n    'i': 'index',\n    'x': 'row',\n    'y': 'col',\n    'z': 'depth',\n    's': 'size',\n    'sx': 'size-row',\n    'sy': 'size-col',\n    'sz': 'size-depth',\n    // legacy names\n    'size-x': 'size-row',\n    'size-y': 'size-col',\n    'size-z': 'size-depth',\n    'multi': 'multiple',\n    'pick-by-turn': 'pick-n',\n    'max-row': 'size-row',\n    'max-col': 'size-col',\n    // error prone\n    'stripes': 'stripe',\n    'strip': 'stripe'\n  });\n  let all = [];\n\n  function get_props(arg) {\n    if (!all.length) {\n      let props = new Set();\n\n      for (let n in document.head.style) {\n        if (!n.startsWith('-')) {\n          props.add(n.replace(/[A-Z]/g, '-$&').toLowerCase());\n        }\n      }\n\n      if (!props.has('grid-gap')) {\n        props.add('grid-gap');\n      }\n\n      all = Array.from(props);\n    }\n\n    return arg && arg.test ? all.filter(n => arg.test(n)) : all;\n  }\n\n  function build_mapping(prefix) {\n    let reg = new RegExp(`\\\\-?${prefix}\\\\-?`);\n    return get_props(reg).map(n => n.replace(reg, '')).reduce((obj, n) => {\n      return obj[n] = n, obj;\n    }, {});\n  }\n\n  const props_webkit_mapping = build_mapping('webkit');\n  const props_moz_mapping = build_mapping('moz');\n\n  function prefixer(prop, rule) {\n    if (props_webkit_mapping[prop]) {\n      return `-webkit-${rule} ${rule}`;\n    } else if (props_moz_mapping[prop]) {\n      return `-moz-${rule} ${rule}`;\n    }\n\n    return rule;\n  }\n\n  const presets = {\n    '4a0': [1682, 2378],\n    '2a0': [1189, 1682],\n    a0: [841, 1189],\n    a1: [594, 841],\n    a2: [420, 594],\n    a3: [297, 420],\n    a4: [210, 297],\n    a5: [148, 210],\n    a6: [105, 148],\n    a7: [74, 105],\n    a8: [52, 74],\n    a9: [37, 52],\n    a10: [26, 37],\n    b0: [1000, 1414],\n    b1: [707, 1000],\n    b2: [500, 707],\n    b3: [353, 500],\n    b4: [250, 353],\n    b5: [176, 250],\n    b6: [125, 176],\n    b7: [88, 125],\n    b8: [62, 88],\n    b9: [44, 62],\n    b10: [31, 44],\n    b11: [22, 32],\n    b12: [16, 22],\n    c0: [917, 1297],\n    c1: [648, 917],\n    c2: [458, 648],\n    c3: [324, 458],\n    c4: [229, 324],\n    c5: [162, 229],\n    c6: [114, 162],\n    c7: [81, 114],\n    c8: [57, 81],\n    c9: [40, 57],\n    c10: [28, 40],\n    c11: [22, 32],\n    c12: [16, 22],\n    d0: [764, 1064],\n    d1: [532, 760],\n    d2: [380, 528],\n    d3: [264, 376],\n    d4: [188, 260],\n    d5: [130, 184],\n    d6: [92, 126],\n    letter: [216, 279],\n    legal: [216, 356],\n    'junior-legal': [203, 127],\n    ledger: [279, 432],\n    tabloid: [279, 432],\n    executive: [190, 254],\n    postcard: [100, 148],\n    'business-card': [54, 90],\n    poster: [390, 540]\n  };\n  const modes = {\n    portrait: 'p',\n    pt: 'p',\n    p: 'p',\n    landscape: 'l',\n    ls: 'l',\n    l: 'l'\n  };\n  const unit = 'mm';\n\n  function get_preset(name, mode) {\n    name = String(name).toLowerCase(); // Default to landscape mode\n\n    let [h, w] = presets[name] || [];\n\n    if (modes[mode] == 'p') {\n      [w, h] = [h, w];\n    }\n\n    return [w, h].map(n => n + unit);\n  }\n\n  function is_preset(name) {\n    return !!presets[name];\n  }\n\n  var Property = {\n    ['@size'](value, {\n      is_special_selector\n    }) {\n      let [w, h = w] = parse$2(value);\n\n      if (is_preset(w)) {\n        [w, h] = get_preset(w, h);\n      }\n\n      return `\n      width: ${w};\n      height: ${h};\n      ${is_special_selector ? '' : `\n        --internal-cell-width: ${w};\n        --internal-cell-height: ${h};\n      `}\n    `;\n    },\n\n    ['@min-size'](value) {\n      let [w, h = w] = parse$2(value);\n      return `min-width: ${w}; min-height: ${h};`;\n    },\n\n    ['@max-size'](value) {\n      let [w, h = w] = parse$2(value);\n      return `max-width: ${w}; max-height: ${h};`;\n    },\n\n    ['@place-cell']: (() => {\n      let map_left_right = {\n        'center': '50%',\n        '0': '0%',\n        'left': '0%',\n        'right': '100%',\n        'top': '50%',\n        'bottom': '50%'\n      };\n      let map_top_bottom = {\n        'center': '50%',\n        '0': '0%',\n        'top': '0%',\n        'bottom': '100%',\n        'left': '50%',\n        'right': '50%'\n      };\n      return value => {\n        let [left, top = '50%'] = parse$2(value);\n        left = map_left_right[left] || left;\n        top = map_top_bottom[top] || top;\n        const cw = 'var(--internal-cell-width, 25%)';\n        const ch = 'var(--internal-cell-height, 25%)';\n        return `\n        position: absolute;\n        left: ${left};\n        top: ${top};\n        width: ${cw};\n        height: ${ch};\n        margin-left: calc(${cw} / -2) !important;\n        margin-top: calc(${ch} / -2) !important;\n        grid-area: unset !important;\n      `;\n      };\n    })(),\n\n    ['@grid'](value, options) {\n      let [grid, ...size] = value.split('/').map(s => s.trim());\n      size = size.join(' / ');\n      return {\n        grid: parse_grid(grid),\n        size: size ? this['@size'](size, options) : ''\n      };\n    },\n\n    ['@shape']: memo$1('shape-property', value => {\n      let [type, ...args] = parse$2(value);\n      let prop = 'clip-path';\n      if (!shapes[type]) return '';\n      let rules = `${prop}: ${shapes[type].apply(null, args)};`;\n      return prefixer(prop, rules) + 'overflow: hidden;';\n    }),\n\n    ['@use'](rules) {\n      if (rules.length > 2) {\n        return rules;\n      }\n    }\n\n  };\n\n  function build_expr(expr) {\n    return n => String(expr).replace(/(\\d+)(n)/g, '$1*' + n).replace(/n/g, n);\n  }\n\n  function nth(input, curr, max) {\n    let expr = build_expr(input);\n\n    for (let i = 0; i <= max; ++i) {\n      if (calc(expr(i)) == curr) return true;\n    }\n  }\n\n  const is$1 = {\n    even: n => !!(n % 2),\n    odd: n => !(n % 2)\n  };\n\n  function even_or_odd(expr) {\n    return /^(even|odd)$/.test(expr);\n  }\n\n  var Selector = {\n    at({\n      x,\n      y\n    }) {\n      return (x1, y1) => x == x1 && y == y1;\n    },\n\n    nth({\n      count,\n      grid\n    }) {\n      return (...exprs) => exprs.some(expr => even_or_odd(expr) ? is$1[expr](count - 1) : nth(expr, count, grid.count));\n    },\n\n    row({\n      x,\n      grid\n    }) {\n      return (...exprs) => exprs.some(expr => even_or_odd(expr) ? is$1[expr](x - 1) : nth(expr, x, grid.x));\n    },\n\n    col({\n      y,\n      grid\n    }) {\n      return (...exprs) => exprs.some(expr => even_or_odd(expr) ? is$1[expr](y - 1) : nth(expr, y, grid.y));\n    },\n\n    even({\n      count\n    }) {\n      return _ => is$1.even(count - 1);\n    },\n\n    odd({\n      count\n    }) {\n      return _ => is$1.odd(count - 1);\n    },\n\n    random() {\n      return (ratio = .5) => {\n        if (ratio >= 1 && ratio <= 0) ratio = .5;\n        return Math.random() < ratio;\n      };\n    }\n\n  }; // Expose all Math functions and constants.\n\n  const methods = Object.getOwnPropertyNames(Math);\n  var MathFunc = methods.reduce((expose, n) => {\n    expose[n] = () => (...args) => {\n      args = args.map(get_value);\n      if (typeof Math[n] === 'number') return Math[n];\n      return Math[n].apply(null, args.map(calc));\n    };\n\n    return expose;\n  }, {});\n\n  function is_host_selector(s) {\n    return /^\\:(host|doodle)/.test(s);\n  }\n\n  function is_parent_selector(s) {\n    return /^\\:(container|parent)/.test(s);\n  }\n\n  function is_special_selector(s) {\n    return is_host_selector(s) || is_parent_selector(s);\n  }\n\n  function is_nil(s) {\n    return s === undefined || s === null;\n  }\n\n  class Rules {\n    constructor(tokens) {\n      this.tokens = tokens;\n      this.rules = {};\n      this.props = {};\n      this.keyframes = {};\n      this.grid = null;\n      this.is_grid_defined = false;\n      this.coords = [];\n      this.reset();\n    }\n\n    reset() {\n      this.styles = {\n        host: '',\n        container: '',\n        cells: '',\n        keyframes: ''\n      };\n      this.coords = [];\n\n      for (let key in this.rules) {\n        if (key.startsWith('#cell')) {\n          delete this.rules[key];\n        }\n      }\n    }\n\n    add_rule(selector, rule) {\n      let rules = this.rules[selector];\n\n      if (!rules) {\n        rules = this.rules[selector] = [];\n      }\n\n      rules.push.apply(rules, make_array(rule));\n    }\n\n    pick_func(name) {\n      return Func[name] || MathFunc[name];\n    }\n\n    apply_func(fn, coords, args) {\n      let _fn = fn(...make_array(coords));\n\n      let input = [];\n      args.forEach(arg => {\n        if (!arg.cluster && typeof arg.value == 'string') {\n          input.push(...parse$2(arg.value, true));\n        } else {\n          if (typeof arg == 'function') {\n            input.push(arg);\n          } else if (arg && arg.value) {\n            input.push(arg.value);\n          }\n        }\n      });\n      input = remove_empty_values(input);\n\n      let result = _fn(...make_array(input));\n\n      return result;\n    }\n\n    compose_aname(...args) {\n      return args.join('-');\n    }\n\n    compose_selector({\n      x,\n      y,\n      z\n    }, pseudo = '') {\n      return `#${cell_id(x, y, z)}${pseudo}`;\n    }\n\n    compose_argument(argument, coords, extra = []) {\n      let result = argument.map(arg => {\n        if (arg.type == 'text') {\n          return arg.value;\n        } else if (arg.type == 'func') {\n          let fn = this.pick_func(arg.name.substr(1));\n\n          if (fn) {\n            coords.extra = extra;\n            coords.position = arg.position;\n            let args = arg.arguments.map(n => {\n              return fn.lazy ? (...extra) => this.compose_argument(n, coords, extra) : this.compose_argument(n, coords, extra);\n            });\n            return this.apply_func(fn, coords, args);\n          }\n        }\n      });\n      return {\n        cluster: argument.cluster,\n        value: result.length >= 2 ? {\n          value: result.join('')\n        } : result[0]\n      };\n    }\n\n    compose_value(value, coords) {\n      if (!value || !value.reduce) return '';\n      let ret = value.reduce((result, val) => {\n        switch (val.type) {\n          case 'text':\n            {\n              result += val.value;\n              break;\n            }\n\n          case 'func':\n            {\n              let fname = val.name.substr(1);\n              let fn = this.pick_func(fname);\n\n              if (fn) {\n                coords.position = val.position;\n                let args = val.arguments.map(arg => {\n                  return fn.lazy ? (...extra) => this.compose_argument(arg, coords, extra) : this.compose_argument(arg, coords);\n                });\n                let output = this.apply_func(fn, coords, args);\n\n                if (!is_nil(output)) {\n                  result += output;\n                }\n              }\n            }\n        }\n\n        return result;\n      }, '');\n      return ret;\n    }\n\n    compose_rule(token, _coords, selector) {\n      let coords = Object.assign({}, _coords);\n      let prop = token.property;\n      let value_group = token.value.reduce((ret, v) => {\n        let composed = this.compose_value(v, coords);\n        if (composed) ret.push(composed);\n        return ret;\n      }, []);\n      let value = value_group.join(', ');\n\n      if (/^animation(\\-name)?$/.test(prop)) {\n        this.props.has_animation = true;\n\n        if (coords.count > 1) {\n          let {\n            count\n          } = coords;\n\n          switch (prop) {\n            case 'animation-name':\n              {\n                value = value_group.map(n => this.compose_aname(n, count)).join(', ');\n                break;\n              }\n\n            case 'animation':\n              {\n                value = value_group.map(n => {\n                  let group = (n || '').split(/\\s+/);\n                  group[0] = this.compose_aname(group[0], count);\n                  return group.join(' ');\n                }).join(', ');\n              }\n          }\n        }\n      }\n\n      if (prop == 'content') {\n        if (!/[\"']|^none$|^(var|counter|counters|attr)\\(/.test(value)) {\n          value = `'${value}'`;\n        }\n      }\n\n      if (prop == 'transition') {\n        this.props.has_transition = true;\n      }\n\n      let rule = `${prop}: ${value};`;\n      rule = prefixer(prop, rule);\n\n      if (prop == 'clip-path') {\n        // fix clip bug\n        rule += ';overflow: hidden;';\n      }\n\n      if (prop == 'width' || prop == 'height') {\n        if (!is_special_selector(selector)) {\n          rule += `--internal-cell-${prop}: ${value};`;\n        }\n      }\n\n      if (Property[prop]) {\n        let transformed = Property[prop](value, {\n          is_special_selector: is_special_selector(selector)\n        });\n\n        switch (prop) {\n          case '@grid':\n            {\n              if (is_host_selector(selector)) {\n                this.grid = transformed.grid;\n                rule = transformed.size || '';\n              } else {\n                rule = '';\n\n                if (!this.is_grid_defined) {\n                  transformed = Property[prop](value, {\n                    is_special_selector: true\n                  });\n                  this.grid = transformed.grid;\n                  this.add_rule(':host', transformed.size || '');\n                }\n              }\n\n              this.is_grid_defined = true;\n              break;\n            }\n\n          case '@place-cell':\n            {\n              if (!is_host_selector(selector)) {\n                rule = transformed;\n              }\n            }\n\n          case '@use':\n            {\n              if (token.value.length) {\n                this.compose(coords, token.value);\n              }\n\n              rule = Property[prop](token.value);\n            }\n\n          default:\n            {\n              rule = transformed;\n            }\n        }\n      }\n\n      return rule;\n    }\n\n    compose(coords, tokens, initial) {\n      this.coords.push(coords);\n      (tokens || this.tokens).forEach((token, i) => {\n        if (token.skip) return false;\n        if (initial && this.grid) return false;\n\n        switch (token.type) {\n          case 'rule':\n            this.add_rule(this.compose_selector(coords), this.compose_rule(token, coords));\n            break;\n\n          case 'pseudo':\n            {\n              if (token.selector.startsWith(':doodle')) {\n                token.selector = token.selector.replace(/^\\:+doodle/, ':host');\n              }\n\n              let special = is_special_selector(token.selector);\n\n              if (special) {\n                token.skip = true;\n              }\n\n              token.selector.split(',').forEach(selector => {\n                let pseudo = token.styles.map(s => this.compose_rule(s, coords, selector));\n                let composed = special ? selector : this.compose_selector(coords, selector);\n                this.add_rule(composed, pseudo);\n              });\n              break;\n            }\n\n          case 'cond':\n            {\n              let fn = Selector[token.name.substr(1)];\n\n              if (fn) {\n                let args = token.arguments.map(arg => {\n                  return this.compose_argument(arg, coords);\n                });\n                let result = this.apply_func(fn, coords, args);\n\n                if (result) {\n                  this.compose(coords, token.styles);\n                }\n              }\n\n              break;\n            }\n\n          case 'keyframes':\n            {\n              if (!this.keyframes[token.name]) {\n                this.keyframes[token.name] = coords => `\n              ${join(token.steps.map(step => `\n                ${step.name} {\n                  ${join(step.styles.map(s => this.compose_rule(s, coords)))}\n                }\n              `))}\n            `;\n              }\n            }\n        }\n      });\n    }\n\n    output() {\n      Object.keys(this.rules).forEach((selector, i) => {\n        if (is_parent_selector(selector)) {\n          this.styles.container += `\n          .container {\n            ${join(this.rules[selector])}\n          }\n        `;\n        } else {\n          let target = is_host_selector(selector) ? 'host' : 'cells';\n          this.styles[target] += `\n          ${selector} {\n            ${join(this.rules[selector])}\n          }\n        `;\n        }\n      });\n      let keyframes = Object.keys(this.keyframes);\n      this.coords.forEach((coords, i) => {\n        keyframes.forEach(name => {\n          let aname = this.compose_aname(name, coords.count);\n          this.styles.keyframes += `\n          ${maybe(i == 0, `@keyframes ${name} {\n              ${this.keyframes[name](coords)}\n            }`)}\n          @keyframes ${aname} {\n            ${this.keyframes[name](coords)}\n          }\n        `;\n        });\n      });\n      return {\n        props: this.props,\n        styles: this.styles,\n        grid: this.grid\n      };\n    }\n\n  }\n\n  function generator(tokens, grid_size) {\n    let rules = new Rules(tokens);\n    let context = {};\n    rules.compose({\n      x: 1,\n      y: 1,\n      z: 1,\n      count: 1,\n      context: {},\n      grid: {\n        x: 1,\n        y: 1,\n        z: 1,\n        count: 1\n      }\n    }, null, true);\n    let {\n      grid\n    } = rules.output();\n    if (grid) grid_size = grid;\n    rules.reset();\n\n    if (grid_size.z == 1) {\n      for (let x = 1, count = 0; x <= grid_size.x; ++x) {\n        for (let y = 1; y <= grid_size.y; ++y) {\n          rules.compose({\n            x,\n            y,\n            z: 1,\n            count: ++count,\n            grid: grid_size,\n            context\n          });\n        }\n      }\n    } else {\n      for (let z = 1, count = 0; z <= grid_size.z; ++z) {\n        rules.compose({\n          x: 1,\n          y: 1,\n          z,\n          count: ++count,\n          grid: grid_size,\n          context\n        });\n      }\n    }\n\n    return rules.output();\n  }\n\n  class Doodle extends HTMLElement {\n    constructor() {\n      super();\n      this.doodle = this.attachShadow({\n        mode: 'open'\n      });\n      this.extra = {\n        get_custom_property_value: this.get_custom_property_value.bind(this)\n      };\n    }\n\n    load(again) {\n      let compiled;\n      let use = this.getAttribute('use') || '';\n      if (use) use = `@use:${use};`;\n      if (!this.innerHTML.trim() && !use) return false;\n\n      try {\n        let parsed = parse$1(use + this.innerHTML, this.extra);\n        this.grid_size = parse_grid(this.getAttribute('grid'));\n        compiled = generator(parsed, this.grid_size);\n        compiled.grid && (this.grid_size = compiled.grid);\n        this.build_grid(compiled);\n      } catch (e) {\n        this.innerHTML = '';\n        console.error(e && e.message || 'Error in css-doodle.');\n      }\n\n      if (!again && this.hasAttribute('click-to-update')) {\n        this.addEventListener('click', e => this.update());\n      }\n    }\n\n    connectedCallback(again) {\n      if (/^(complete|interactive|loaded)$/.test(document.readyState)) {\n        this.load();\n      } else {\n        setTimeout(() => this.load(again));\n      }\n    }\n\n    get_custom_property_value(name) {\n      return getComputedStyle(this).getPropertyValue(name).trim().replace(/^\\(|\\)$/g, '');\n    }\n\n    cell(x, y, z) {\n      let cell = document.createElement('div');\n      cell.id = cell_id(x, y, z);\n      return cell;\n    }\n\n    build_grid(compiled) {\n      const {\n        has_transition,\n        has_animation\n      } = compiled.props;\n      const {\n        keyframes,\n        host,\n        container,\n        cells\n      } = compiled.styles;\n      this.doodle.innerHTML = `\n      <style>\n        ${this.style_basic()}\n      </style>\n      <style class=\"style-keyframes\">\n        ${keyframes}\n      </style>\n      <style class=\"style-container\">\n        ${this.style_size()}\n        ${host}\n        ${container}\n      </style>\n      <style class=\"style-cells\">\n        ${has_transition || has_animation ? '' : cells}\n      </style>\n      <div class=\"container\"></div>\n    `;\n      this.doodle.querySelector('.container').appendChild(this.html_cells());\n\n      if (has_transition || has_animation) {\n        setTimeout(() => {\n          this.set_style('.style-cells', cells);\n        }, 50);\n      }\n    }\n\n    inherit_props(p) {\n      return get_props(/grid/).map(n => `${n}: inherit;`).join('');\n    }\n\n    style_basic() {\n      return `\n      * {\n        box-sizing: border-box;\n      }\n      *::after, *::before {\n        box-sizing: inherit;\n      }\n      :host {\n        display: block;\n        visibility: visible;\n        width: auto;\n        height: auto;\n      }\n      .container {\n        position: relative;\n        width: 100%;\n        height: 100%;\n        display: grid;\n        ${this.inherit_props()}\n      }\n      .container div:empty {\n        position: relative;\n        line-height: 1;\n        display: grid;\n        place-items: center;\n      }\n    `;\n    }\n\n    style_size() {\n      let {\n        x,\n        y\n      } = this.grid_size;\n      return `\n      :host {\n        grid-template-rows: repeat(${x}, 1fr);\n        grid-template-columns: repeat(${y}, 1fr);\n      }\n    `;\n    }\n\n    html_cells() {\n      let {\n        x,\n        y,\n        z\n      } = this.grid_size;\n      let root = document.createDocumentFragment();\n\n      if (z == 1) {\n        for (let i = 1; i <= x; ++i) {\n          for (let j = 1; j <= y; ++j) {\n            root.appendChild(this.cell(i, j, 1));\n          }\n        }\n      } else {\n        let temp = null;\n\n        for (let i = 1; i <= z; ++i) {\n          let cell = this.cell(1, 1, i);\n          (temp || root).appendChild(cell);\n          temp = cell;\n        }\n\n        temp = null;\n      }\n\n      return root;\n    }\n\n    set_style(selector, styles) {\n      const el = this.shadowRoot.querySelector(selector);\n      el && (el.styleSheet ? el.styleSheet.cssText = styles : el.innerHTML = styles);\n    }\n\n    update(styles) {\n      let use = this.getAttribute('use') || '';\n      if (use) use = `@use:${use};`;\n      if (!styles) styles = this.innerHTML;\n      this.innerHTML = styles;\n\n      if (!this.grid_size) {\n        this.grid_size = parse_grid(this.getAttribute('grid'));\n      }\n\n      const compiled = generator(parse$1(use + styles, this.extra), this.grid_size);\n\n      if (compiled.grid) {\n        let {\n          x,\n          y,\n          z\n        } = compiled.grid;\n        let {\n          x: gx,\n          y: gy,\n          z: gz\n        } = this.grid_size;\n\n        if (gx !== x || gy !== y || gz !== z) {\n          Object.assign(this.grid_size, compiled.grid);\n          return this.build_grid(compiled);\n        }\n\n        Object.assign(this.grid_size, compiled.grid);\n      } else {\n        let grid = parse_grid(this.getAttribute('grid'));\n        let {\n          x,\n          y,\n          z\n        } = grid;\n        let {\n          x: gx,\n          y: gy,\n          z: gz\n        } = this.grid_size;\n\n        if (gx !== x || gy !== y || gz !== z) {\n          Object.assign(this.grid_size, grid);\n          return this.build_grid(generator(parse$1(use + styles, this.extra), this.grid_size));\n        }\n      }\n\n      this.set_style('.style-keyframes', compiled.styles.keyframes);\n\n      if (compiled.props.has_animation) {\n        this.set_style('.style-cells', '');\n        this.set_style('.style-container', '');\n      }\n\n      setTimeout(() => {\n        this.set_style('.style-container', this.style_size() + compiled.styles.host + compiled.styles.container);\n        this.set_style('.style-cells', compiled.styles.cells);\n      });\n    }\n\n    get grid() {\n      return Object.assign({}, this.grid_size);\n    }\n\n    set grid(grid) {\n      this.setAttribute('grid', grid);\n      this.connectedCallback(true);\n    }\n\n    get use() {\n      return this.getAttribute('use');\n    }\n\n    set use(use) {\n      this.setAttribute('use', use);\n      this.connectedCallback(true);\n    }\n\n    static get observedAttributes() {\n      return ['grid', 'use'];\n    }\n\n    attributeChangedCallback(name, old_val, new_val) {\n      if (old_val == new_val) {\n        return false;\n      }\n\n      if (name == 'grid' && old_val) {\n        this.grid = new_val;\n      }\n\n      if (name == 'use' && old_val) {\n        this.use = new_val;\n      }\n    }\n\n  }\n\n  if (!customElements.get('css-doodle')) {\n    customElements.define('css-doodle', Doodle);\n  }\n\n  function CSSDoodle(input, ...vars) {\n    let get_value = v => v !== undefined && v !== null ? v : '';\n\n    let rules = input.reduce((s, c, i) => s + c + get_value(vars[i]), '');\n    let doodle = document.createElement('css-doodle');\n\n    if (doodle.update) {\n      doodle.update(rules);\n    }\n\n    return doodle;\n  }\n\n  return CSSDoodle;\n});","map":{"version":3,"sources":["/home/parth/Desktop/protfolio/protfolio/node_modules/css-doodle/css-doodle.js"],"names":["global","factory","exports","module","define","amd","self","CSSDoodle","iterator","input","index","col","line","curr","n","end","length","info","undefined","next","parse","it","word","marks","groups","result","c","push","test","name","alternative","pop","Error","parse_var","trim","e","console","error","message","make_array","arr","Array","isArray","join","spliter","last","first","clone","JSON","stringify","shuffle","ret","from","slice","m","i","Math","random","t","flat_map","fn","prototype","flatMap","reduce","acc","x","concat","remove_empty_values","filter","v","String","Tokens","func","type","arguments","argument","value","text","pseudo","selector","styles","cond","rule","property","keyframes","steps","step","is","white_space","line_break","number","isNaN","pair","includes","pair_of","symbols","PI","throw_error","msg","get_text_value","read_until","reset","read_word","check","read_keyframe_name","read_line","read_step","extra","read_selector","read_rule","read_steps","read_keyframes","read_comments","flag","inline","read_property","prop","read_arguments","composition","args","group","stack","arg","trimLeft","read_func","startsWith","raw","substr","cloned","normalize_argument","map","replace","ft","ed","cf","ce","cluster","seperate_func_name","fname","substring","has_argument","unshift","position","read_value","idx","skip","read_cond_selector","read_pseudo","read_var","read_cond","Object","assign","read_property_value","get_custom_property_value","evaluate_value","values","forEach","vars","p","other","parsed","every","parse$1","apply","token","clamp","num","min","max","maybe","range","start","stop","count","old","initial","alias_for","obj","names","keys","is_letter","lazy","wrap","sequence","cell_id","y","z","get_value","total","parse_grid","size","split","Number","max_xy","max_z","create_svg_url","svg","id","blob","Blob","url","URL","createObjectURL","encoded","encodeURIComponent","normalize_svg","xmlns","lerp","rand","pick","items","unique_id","prefix","toString","by_unit","unit","get_unit","restore","str","some","matched","match","by_charcode","codes","charCodeAt","fromCharCode","calc","expr","infix_to_postfix","top","shift","right","left","compute","operator","get_tokens","tokens","op_stack","op","a","b","store","memo$1","key","expand","build_range","Type","get_tokens$1","endsWith","to","reverse","Node","constructor","data","prev","Stack","limit","_limit","_size","root","node","tail","cos","sin","sqrt","pow","DEG","polygon","option","scale","deg","points","rotate","rad","shapes","circle","triangle","rhombus","pentagon","hexgon","hexagon","heptagon","octagon","star","diamond","cross","clover","k","hypocycloid","astroid","infinity","heart","bean","bicorn","drop","pear","fish","whale","r","bud","alien","d","is_seperator","no_space","skip_seperator","parse$2","Expose","_","row","depth","grid","N","repeat","make_sequence","multiple","context","push_stack","counter","pos","last_pick","transform_type","parseInt","last_rand","stripe","colors","default_count","custom_sizes","default_size","color","hex","var","shape","memo","action","Func","all","get_props","props","Set","document","head","style","add","toLowerCase","has","build_mapping","reg","RegExp","props_webkit_mapping","props_moz_mapping","prefixer","presets","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","b10","b11","b12","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","c10","c11","c12","d0","d1","d2","d3","d4","d5","d6","letter","legal","ledger","tabloid","executive","postcard","poster","modes","portrait","pt","landscape","ls","l","get_preset","mode","h","w","is_preset","Property","is_special_selector","map_left_right","map_top_bottom","cw","ch","options","s","rules","build_expr","nth","is$1","even","odd","even_or_odd","Selector","at","x1","y1","exprs","ratio","methods","getOwnPropertyNames","MathFunc","expose","is_host_selector","is_parent_selector","is_nil","Rules","is_grid_defined","coords","host","container","cells","add_rule","pick_func","apply_func","_fn","compose_aname","compose_selector","compose_argument","compose_value","val","output","compose_rule","_coords","value_group","composed","has_animation","has_transition","transformed","compose","special","target","aname","generator","grid_size","Doodle","HTMLElement","doodle","attachShadow","bind","load","again","compiled","use","getAttribute","innerHTML","build_grid","hasAttribute","addEventListener","update","connectedCallback","readyState","setTimeout","getComputedStyle","getPropertyValue","cell","createElement","style_basic","style_size","querySelector","appendChild","html_cells","set_style","inherit_props","createDocumentFragment","j","temp","el","shadowRoot","styleSheet","cssText","gx","gy","gz","setAttribute","observedAttributes","attributeChangedCallback","old_val","new_val","customElements","get"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.CSSDoodle = factory());\n}(this, (function () { 'use strict';\n\n  function iterator(input) {\n    let index = 0, col = 1, line = 1;\n    return {\n      curr(n = 0) {\n        return input[index + n];\n      },\n      end() {\n        return input.length <= index;\n      },\n      info() {\n        return { index, col, line };\n      },\n      index(n) {\n        return (n === undefined ? index : index = n);\n      },\n      next() {\n        let next = input[index++];\n        if (next == '\\n') line++, col = 0;\n        else col++;\n        return next;\n      }\n    };\n  }\n\n  // I'll make it work first\n  function parse(it) {\n    let word = '', marks = [];\n    let groups = [], result = {};\n\n    while(!it.end()) {\n      let c = it.curr();\n      if (c == '(') {\n        marks.push(c);\n        word = '';\n      }\n      else if (c == ')' || c == ',') {\n        if (/^\\-\\-.+/.test(word)) {\n          if (!result.name) {\n            result.name = word;\n          } else {\n            if (!result.alternative) {\n              result.alternative = [];\n            }\n            result.alternative.push({\n              name: word\n            });\n          }\n        }\n\n        if (c == ')') {\n          if (marks[marks.length - 1] == '(') {\n            marks.pop();\n          } else {\n            throw new Error('bad match');\n          }\n        }\n\n        if (c == ',') {\n          if (!marks.length) {\n            groups.push(result);\n            result = {};\n          }\n        }\n\n        word = '';\n      }\n      else if (!/\\s/.test(c)) {\n        word += c;\n      }\n      it.next();\n    }\n\n    if (marks.length) {\n      return [];\n    }\n\n    if (result.name) {\n      groups.push(result);\n    }\n    return groups;\n  }\n\n  function parse_var(input) {\n    input = input.trim();\n    let result = [];\n    if (!/^var\\(/.test(input)) {\n      return result;\n    }\n    let it = iterator(input);\n    try {\n      result = parse(it);\n    } catch (e) {\n      console.error(e && e.message || 'Bad variables.');\n    }\n    return result;\n  }\n\n  function make_array(arr) {\n    return Array.isArray(arr) ? arr : [arr];\n  }\n\n  function join(arr, spliter = '\\n') {\n    return (arr || []).join(spliter);\n  }\n\n  function last(arr, n = 1) {\n    return arr[arr.length - n];\n  }\n\n  function first(arr) {\n    return arr[0];\n  }\n\n  function clone(arr) {\n    return JSON.parse(JSON.stringify(arr));\n  }\n\n  function shuffle(arr) {\n    let ret = Array.from ? Array.from(arr) : arr.slice();\n    let m = arr.length;\n    while (m) {\n      let i = ~~(Math.random() * m--);\n      let t = ret[m];\n      ret[m] = ret[i];\n      ret[i] = t;\n    }\n    return ret;\n  }\n\n  function flat_map(arr, fn) {\n    if (Array.prototype.flatMap) return arr.flatMap(fn);\n    return arr.reduce((acc, x) => acc.concat(fn(x)), []);\n  }\n\n  function remove_empty_values(arr) {\n    return arr.filter(v => (\n      v !== undefined &&\n      v !== null &&\n      String(v).trim().length\n    ));\n  }\n\n  const Tokens = {\n    func(name = '') {\n      return {\n        type: 'func',\n        name,\n        arguments: []\n      };\n    },\n    argument() {\n      return {\n        type: 'argument',\n        value: []\n      };\n    },\n    text(value = '') {\n      return {\n        type: 'text',\n        value\n      };\n    },\n    pseudo(selector = '') {\n      return {\n        type: 'pseudo',\n        selector,\n        styles: []\n      };\n    },\n    cond(name = '') {\n      return {\n        type: 'cond',\n        name,\n        styles: [],\n        arguments: []\n      };\n    },\n    rule(property = '') {\n      return {\n        type: 'rule',\n        property,\n        value: []\n      };\n    },\n    keyframes(name = '') {\n      return {\n        type: 'keyframes',\n        name,\n        steps: []\n      }\n    },\n\n    step(name = '') {\n      return {\n        type: 'step',\n        name,\n        styles: []\n      }\n    }\n  };\n\n  const is = {\n    white_space(c) {\n      return /[\\s\\n\\t]/.test(c);\n    },\n    line_break(c) {\n      return /\\n/.test(c);\n    },\n    number(n) {\n      return !isNaN(n);\n    },\n    pair(n) {\n      return ['\"', '(', ')', \"'\"].includes(n);\n    },\n    pair_of(c, n) {\n      return ({ '\"': '\"', \"'\": \"'\", '(': ')' })[c] == n;\n    }\n  };\n\n  // This should not be in the parser\n  // but I'll leave it here until the rewriting\n  const symbols = {\n    'π': Math.PI,\n    '∏': Math.PI\n  };\n\n  function throw_error(msg, { col, line }) {\n    console.error(\n      `(at line ${ line }, column ${ col }) ${ msg }`\n    );\n  }\n\n  function get_text_value(input) {\n    if (input.trim().length) {\n      return is.number(+input) ? +input : input.trim()\n    } else {\n      return input;\n    }\n  }\n\n  function read_until(fn) {\n    return function(it, reset) {\n      let index = it.index();\n      let word = '';\n      while (!it.end()) {\n        let c = it.next();\n        if (fn(c)) break;\n        else word += c;\n      }\n      if (reset) {\n        it.index(index);\n      }\n      return word;\n    }\n  }\n\n  function read_word(it, reset) {\n    let check = c => /[^\\w@]/.test(c);\n    return read_until(check)(it, reset);\n  }\n\n  function read_keyframe_name(it) {\n    return read_until(c => /[\\s\\{]/.test(c))(it);\n  }\n\n  function read_line(it, reset) {\n    let check = c => is.line_break(c) || c == '{';\n    return read_until(check)(it, reset);\n  }\n\n  function read_step(it, extra) {\n    let c, step = Tokens.step();\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else if (!step.name.length) {\n        step.name = read_selector(it);\n      }\n      else {\n        step.styles.push(read_rule(it, extra));\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return step;\n  }\n\n  function read_steps(it, extra) {\n    const steps = [];\n    let c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      else if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else {\n        steps.push(read_step(it, extra));\n      }\n      it.next();\n    }\n    return steps;\n  }\n\n  function read_keyframes(it, extra) {\n    let keyframes = Tokens.keyframes(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      else if (!keyframes.name.length) {\n        read_word(it);\n        keyframes.name = read_keyframe_name(it);\n        if (!keyframes.name.length) {\n          throw_error('missing keyframes name', it.info());\n          break;\n        }\n        continue;\n      }\n      else if (c == '{') {\n        it.next();\n        keyframes.steps = read_steps(it, extra);\n        break;\n      }\n      it.next();\n    }\n    return keyframes;\n  }\n\n  function read_comments(it, flag = {}) {\n    it.next();\n    while (!it.end()) {\n      let c = it.curr();\n      if (flag.inline) {\n        if (c == '\\n') break;\n      }\n      else {\n        if ((c = it.curr()) == '*' && it.curr(1) == '/') break;\n      }\n      it.next();\n    }\n    if (!flag.inline) {\n      it.next(); it.next();\n    }\n  }\n\n  function read_property(it) {\n    let prop = '', c;\n    while (!it.end()) {\n      if ((c = it.curr()) == ':') break;\n      else if (!is.white_space(c)) prop += c;\n      it.next();\n    }\n    return prop;\n  }\n\n  function read_arguments(it, composition) {\n    let args = [], group = [], stack = [], arg = '', c;\n    while (!it.end()) {\n      c = it.curr();\n      if ((/[\\('\"`]/.test(c) && it.curr(-1) !== '\\\\')) {\n        if (stack.length) {\n          if (c != '(' && c === last(stack)) {\n            stack.pop();\n          } else {\n            stack.push(c);\n          }\n        } else {\n          stack.push(c);\n        }\n        arg += c;\n      }\n      else if (c == '@') {\n        if (!group.length) {\n          arg = arg.trimLeft();\n        }\n        if (arg.length) {\n          group.push(Tokens.text(arg));\n          arg = '';\n        }\n        group.push(read_func(it));\n      }\n      else if (/[,)]/.test(c)) {\n        if (stack.length) {\n          if (c == ')') {\n            stack.pop();\n          }\n          arg += c;\n        }\n\n        else {\n          if (arg.length) {\n            if (!group.length) {\n              group.push(Tokens.text(get_text_value(arg)));\n            } else {\n              group.push(Tokens.text(arg));\n            }\n\n            if (arg.startsWith('±')) {\n              let raw = arg.substr(1);\n              let cloned = clone(group);\n              last(cloned).value = '-' + raw;\n              args.push(normalize_argument(cloned));\n              last(group).value = raw;\n            }\n          }\n\n          args.push(normalize_argument(group));\n\n          [group, arg] = [[], ''];\n\n          if (c == ')') break;\n        }\n      }\n      else {\n        if (symbols[c]) {\n          c = symbols[c];\n        }\n        arg += c;\n      }\n\n      if (composition && it.curr() == ')' && !stack.length) {\n        if (group.length) {\n          args.push(normalize_argument(group));\n        }\n        break;\n      }\n      else {\n        it.next();\n      }\n    }\n\n    return args;\n  }\n\n  function normalize_argument(group) {\n    let result = group.map(arg => {\n      if (arg.type == 'text' && typeof arg.value == 'string') {\n        let value = String(arg.value);\n        if (value.includes('`')) {\n          arg.value = value = value.replace(/`/g, '\"');\n        }\n        arg.value = value.replace(/\\n+|\\s+/g, ' ');\n      }\n      return arg;\n    });\n\n    let ft = first(result) || {};\n    let ed = last(result) || {};\n    if (ft.type == 'text' && ed.type == 'text') {\n      let cf = first(ft.value);\n      let ce  = last(ed.value);\n      if (typeof ft.value == 'string' && typeof ed.value == 'string') {\n        if (is.pair_of(cf, ce)) {\n          ft.value = ft.value.slice(1);\n          ed.value = ed.value.slice(0, ed.value.length - 1);\n          result.cluster = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function seperate_func_name(name) {\n    let fname = '', extra = '';\n    if (/\\D$/.test(name) || Math[name.substr(1)]) {\n      return { fname: name, extra }\n    }\n    for (let i = name.length - 1; i >= 0; i--) {\n      let c = name[i];\n      if (/[\\d.]/.test(c)) {\n        extra = c + extra;\n      } else {\n        fname = name.substring(0, i + 1);\n        break;\n      }\n    }\n    return { fname, extra };\n  }\n\n  function read_func(it) {\n    let func = Tokens.func();\n    let name = '@', c;\n    let has_argument = false;\n    it.next();\n\n    while (!it.end()) {\n      c = it.curr();\n      let composition = (c == '.' && it.curr(1) == '@');\n      let next = it.curr(1);\n      if (c == '(' || composition) {\n        has_argument = true;\n        it.next();\n        func.arguments = read_arguments(it, composition);\n        break;\n      } else if (!has_argument && next !== '(' && !/[0-9a-zA-Z_\\-.]/.test(next)) {\n        name += c;\n        break;\n      }\n      else {\n        name += c;\n      }\n      it.next();\n    }\n\n    let { fname, extra } = seperate_func_name(name);\n    func.name = fname;\n\n    if (extra.length) {\n      func.arguments.unshift([{\n        type: 'text',\n        value: extra\n      }]);\n    }\n\n    func.position = it.info().index;\n    return func;\n  }\n\n  function read_value(it) {\n    let text = Tokens.text(), idx = 0, skip = true, c;\n    const value = [], stack = [];\n    value[idx] = [];\n\n    while (!it.end()) {\n      c = it.curr();\n\n      if (skip && is.white_space(c)) {\n        it.next();\n        continue;\n      } else {\n        skip = false;\n      }\n\n      if (c == '\\n' && !is.white_space(it.curr(-1))) {\n        text.value += ' ';\n      }\n      else if (c == ',' && !stack.length) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        value[++idx] = [];\n        skip = true;\n      }\n      else if (/[;}]/.test(c)) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        break;\n      }\n      else if (c == '@') {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        value[idx].push(read_func(it));\n      }\n      else if (!is.white_space(c) || !is.white_space(it.curr(-1))) {\n        if (c == '(') stack.push(c);\n        if (c == ')') stack.pop();\n\n        if (symbols[c]) {\n          c = symbols[c];\n        }\n\n        text.value += c;\n      }\n      it.next();\n    }\n    if (text.value.length) {\n      value[idx].push(text);\n    }\n    return value;\n  }\n\n  function read_selector(it) {\n    let selector = '', c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '{') break;\n      else if (!is.white_space(c)) {\n        selector += c;\n      }\n      it.next();\n    }\n    return selector;\n  }\n\n  function read_cond_selector(it) {\n    let selector = { name: '', arguments: [] }, c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '(') {\n        it.next();\n        selector.arguments = read_arguments(it);\n      }\n      else if (/[){]/.test(c)) break;\n      else if (!is.white_space(c)) selector.name += c;\n      it.next();\n    }\n    return selector;\n  }\n\n  function read_pseudo(it, extra) {\n    let pseudo = Tokens.pseudo(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else if (!pseudo.selector) {\n        pseudo.selector = read_selector(it);\n      }\n      else {\n        let rule = read_rule(it, extra);\n        if (rule.property == '@use') {\n          pseudo.styles = pseudo.styles.concat(\n            rule.value\n          );\n        } else {\n          pseudo.styles.push(rule);\n        }\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return pseudo;\n  }\n\n  function read_rule(it, extra) {\n    let rule = Tokens.rule(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == ';') break;\n      else if (!rule.property.length) {\n        rule.property = read_property(it);\n        if (rule.property == '@use') {\n          rule.value = read_var(it, extra);\n          break;\n        }\n      }\n      else {\n        rule.value = read_value(it);\n        break;\n      }\n      it.next();\n    }\n    return rule;\n  }\n\n  function read_cond(it, extra) {\n    let cond = Tokens.cond(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      else if (!cond.name.length) {\n        Object.assign(cond, read_cond_selector(it));\n      }\n      else if (c == ':') {\n        let pseudo = read_pseudo(it);\n        if (pseudo.selector) cond.styles.push(pseudo);\n      }\n      else if (c == '@' && !read_line(it, true).includes(':')) {\n        cond.styles.push(read_cond(it));\n      }\n      else if (!is.white_space(c)) {\n        let rule = read_rule(it, extra);\n        if (rule.property) cond.styles.push(rule);\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return cond;\n  }\n\n  function read_property_value(extra, name) {\n    let rule = '';\n    if (extra && extra.get_custom_property_value) {\n      rule = extra.get_custom_property_value(name);\n    }\n    return rule;\n  }\n\n  function evaluate_value(values, extra) {\n    values.forEach && values.forEach(v => {\n      if (v.type == 'text' && v.value) {\n        let vars = parse_var(v.value);\n        v.value = vars.reduce((ret, p) => {\n          let rule = '', other = '', parsed;\n          rule = read_property_value(extra, p.name);\n          if (!rule && p.alternative) {\n            p.alternative.every(n => {\n              other = read_property_value(extra, n.name);\n              if (other) {\n                rule = other;\n                return false;\n              }\n            });\n          }\n          try {\n            parsed = parse$1(rule, extra);\n          } catch (e) { }\n          if (parsed) {\n            ret.push.apply(ret, parsed);\n          }\n          return ret;\n        }, []);\n      }\n      if (v.type == 'func' && v.arguments) {\n        v.arguments.forEach(arg => {\n          evaluate_value(arg, extra);\n        });\n      }\n    });\n  }\n\n  function read_var(it, extra) {\n    it.next();\n    let groups = read_value(it) || [];\n    return groups.reduce((ret, group) => {\n      evaluate_value(group, extra);\n      let [token] = group;\n      if (token.value && token.value.length) {\n        ret.push(...token.value);\n      }\n      return ret;\n    }, []);\n  }\n\n  function parse$1(input, extra) {\n    const it = iterator(input);\n    const Tokens = [];\n    while (!it.end()) {\n      let c = it.curr();\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else if (c == '/' && it.curr(1) == '*') {\n        read_comments(it);\n      }\n      else if (c == '/' && it.curr(1) == '/') {\n        read_comments(it, { inline: true });\n      }\n      else if (c == ':') {\n        let pseudo = read_pseudo(it, extra);\n        if (pseudo.selector) Tokens.push(pseudo);\n      }\n      else if (c == '@' && read_word(it, true) === '@keyframes') {\n        let keyframes = read_keyframes(it, extra);\n        Tokens.push(keyframes);\n      }\n      else if (c == '@' && !read_line(it, true).includes(':')) {\n        let cond = read_cond(it, extra);\n        if (cond.name.length) Tokens.push(cond);\n      }\n      else if (!is.white_space(c)) {\n        let rule = read_rule(it, extra);\n        if (rule.property) Tokens.push(rule);\n      }\n      it.next();\n    }\n    return Tokens;\n  }\n\n  function clamp(num, min, max) {\n    return Math.max(min, Math.min(max, num));\n  }\n\n  function maybe(cond, value) {\n    if (!cond) return '';\n    return (typeof value === 'function') ? value() : value;\n  }\n\n  function range(start, stop, step) {\n    let count = 0, old = start;\n    let initial = n => (n > 0 && n < 1) ? .1 : 1;\n    let length = arguments.length;\n    if (length == 1) [start, stop] = [initial(start), start];\n    if (length < 3) step = initial(start);\n    let range = [];\n    while ((step >= 0 && start <= stop)\n      || (step < 0 && start > stop)) {\n      range.push(start);\n      start += step;\n      if (count++ >= 1000) break;\n    }\n    if (!range.length) range.push(old);\n    return range;\n  }\n\n  function alias_for(obj, names) {\n    Object.keys(names).forEach(n => {\n      obj[n] = obj[names[n]];\n    });\n    return obj;\n  }\n\n  function is_letter(c) {\n    return /^[a-zA-Z]$/.test(c);\n  }\n\n  function lazy(fn) {\n    let wrap = () => fn;\n    wrap.lazy = true;\n    return wrap;\n  }\n\n  function sequence(count, fn) {\n    let ret = [];\n    for (let i = 0; i < count; ++i) {\n      ret.push(fn(i));\n    }\n    return ret;\n  }\n\n  function cell_id(x, y, z) {\n    return 'cell-' + x + '-' + y + '-' + z;\n  }\n\n  function get_value(input) {\n    while (input && input.value) {\n      return get_value(input.value);\n    }\n    return input || '';\n  }\n\n  const [ min, max, total ] = [ 1, 64, 64 * 64 ];\n\n  function parse_grid(size) {\n    let [x, y, z] = (size + '')\n      .replace(/\\s+/g, '')\n      .replace(/[,，xX]+/g, 'x')\n      .split('x')\n      .map(Number);\n\n    const max_xy = (x == 1 || y == 1) ? total : max;\n    const max_z = (x == 1 && y == 1) ? total : min;\n\n    const ret = {\n      x: clamp(x || min, 1, max_xy),\n      y: clamp(y || x || min, 1, max_xy),\n      z: clamp(z || min, 1, max_z)\n    };\n\n    return Object.assign({}, ret,\n      { count: ret.x * ret.y * ret.z }\n    );\n  }\n\n  function create_svg_url(svg, id) {\n    if (id) {\n      let blob = new Blob([svg], { type: 'image/svg+xml' });\n      let url = URL.createObjectURL(blob);\n      return `url(${ url }#${ id })`;\n    }\n    else {\n      let encoded = encodeURIComponent(svg);\n      return `url(\"data:image/svg+xml;utf8,${ encoded }\")`;\n    }\n  }\n\n  function normalize_svg(input) {\n    const xmlns = 'xmlns=\"http://www.w3.org/2000/svg\"';\n    if (!input.includes('<svg')) {\n      input = `<svg ${ xmlns }>${ input }</svg>`;\n    }\n    if (!input.includes('xmlns')) {\n      input = input.replace(/<svg([\\s>])/, `<svg ${ xmlns }$1`);\n    }\n    return input;\n  }\n\n  function lerp(start, end, t) {\n    return start * (1 - t) + end * t;\n  }\n\n  function rand(start = 0, end = start) {\n    if (arguments.length == 1) {\n      if (start == 1) start = 0;\n      else if (start < 1) start /= 10;\n      else start = 1;\n    }\n    return lerp(start, end, Math.random());\n  }\n\n  function pick(...items) {\n    let args = items.reduce((acc, n) => acc.concat(n), []);\n    return args[~~(Math.random() * args.length)];\n  }\n\n  function unique_id(prefix = '') {\n    return prefix + Math.random().toString(32).substr(2);\n  }\n\n  function by_unit(fn) {\n    return (...args) => {\n      let unit = get_unit(args);\n      return restore(fn, unit).apply(null, args);\n    }\n  }\n\n  function restore(fn, unit) {\n    return (...args) => {\n      args = args.map(str => Number(\n        String(str).replace(/\\D+$/g, '')\n      ));\n      let result = fn.apply(null, args);\n      if (!unit.length) {\n        return result;\n      }\n      if (Array.isArray(result)) {\n        return result.map(n => n + unit);\n      }\n      return result + unit;\n    }\n  }\n\n  function get_unit(values) {\n    let unit = '';\n    values.some(str => {\n      let input = String(str).trim();\n      if (!input) return '';\n      let matched = input.match(/\\d(\\D+)$/);\n      return (unit = matched ? matched[1] : '');\n    });\n    return unit;\n  }\n\n  function by_charcode(fn) {\n    return (...args) => {\n      let codes = args.map(n => String(n).charCodeAt(0));\n      let result = fn.apply(null, codes);\n      return Array.isArray(result)\n        ? result.map(n => String.fromCharCode(n))\n        : String.fromCharCode(result);\n    }\n  }\n\n  /**\n   * Based on the Shunting-yard algorithm.\n   */\n\n  function calc(input) {\n    const expr = infix_to_postfix(input), stack = [];\n    while (expr.length) {\n      let top = expr.shift();\n      if (/\\d+/.test(top)) stack.push(top);\n      else {\n        let right = stack.pop();\n        let left = stack.pop();\n        stack.push(compute(\n          top, Number(left), Number(right)\n        ));\n      }\n    }\n    return stack[0];\n  }\n\n  const operator = {\n    '*': 3, '/': 3, '%': 3,\n    '+': 2, '-': 2,\n    '(': 1, ')': 1\n  };\n\n  function get_tokens(input) {\n    let expr = String(input);\n    let tokens = [], num = '';\n\n    for (let i = 0; i < expr.length; ++i) {\n      let c = expr[i];\n\n      if (operator[c]) {\n        if (c == '-' && expr[i - 1] == 'e') {\n          num += c;\n        }\n        else if (!tokens.length && !num.length && /[+-]/.test(c)) {\n          num += c;\n        } else {\n          let { type, value } = last(tokens) || {};\n          if (type == 'operator'\n              && !num.length\n              && /[^()]/.test(c)\n              && /[^()]/.test(value)) {\n            num += c;\n          } else {\n            if (num.length) {\n              tokens.push({ type: 'number', value: num });\n              num = '';\n            }\n            tokens.push({ type: 'operator', value: c });\n          }\n        }\n      }\n\n      else if (/\\S/.test(c)) {\n        num += c;\n      }\n    }\n\n    if (num.length) {\n      tokens.push({ type: 'number', value: num });\n    }\n\n    return tokens;\n  }\n\n  function infix_to_postfix(input) {\n    let tokens = get_tokens(input);\n    const op_stack = [], expr = [];\n\n    for (let i = 0; i < tokens.length; ++i) {\n      let { type, value } = tokens[i];\n      if (type == 'number') {\n        expr.push(value);\n      }\n\n      else if (type == 'operator') {\n        if (value == '(') {\n          op_stack.push(value);\n        }\n\n        else if (value == ')') {\n          while (op_stack.length && last(op_stack) != '(') {\n            expr.push(op_stack.pop());\n          }\n          op_stack.pop();\n        }\n\n        else {\n          while (op_stack.length && operator[last(op_stack)] >= operator[value]) {\n            let op = op_stack.pop();\n            if (!/[()]/.test(op)) expr.push(op);\n          }\n          op_stack.push(value);\n        }\n      }\n    }\n\n    while (op_stack.length) {\n      expr.push(op_stack.pop());\n    }\n\n    return expr;\n  }\n\n  function compute(op, a, b) {\n    switch (op) {\n      case '+': return a + b;\n      case '-': return a - b;\n      case '*': return a * b;\n      case '/': return a / b;\n      case '%': return a % b;\n    }\n  }\n\n  const store = {};\n\n  function memo$1(prefix, fn) {\n    return (...args) => {\n      let key = prefix + args.join('-');\n      if (store[key]) return store[key];\n      return (store[key] = fn.apply(null, args));\n    }\n  }\n\n  function expand(fn) {\n    return (...args) => fn.apply(null, flat_map(args, n =>\n      String(n).startsWith('[') ? build_range(n) : n\n    ));\n  }\n\n  function Type(type, value) {\n    return { type, value };\n  }\n\n  function get_tokens$1(input) {\n    let expr = String(input);\n    let tokens = [], stack = [];\n    if (!expr.startsWith('[') || !expr.endsWith(']')) {\n      return tokens;\n    }\n\n    for (let i = 1; i < expr.length - 1; ++i) {\n      let c = expr[i];\n      if (c == '-' && expr[i - 1] == '-') {\n        continue;\n      }\n      if (c == '-') {\n        stack.push(c);\n        continue;\n      }\n      if (last(stack) == '-') {\n        stack.pop();\n        let from = stack.pop();\n        tokens.push(from\n          ? Type('range', [ from, c ])\n          : Type('char', c)\n        );\n        continue;\n      }\n      if (stack.length) {\n        tokens.push(Type('char', stack.pop()));\n      }\n      stack.push(c);\n    }\n    if (stack.length) {\n      tokens.push(Type('char', stack.pop()));\n    }\n    return tokens;\n  }\n\n  const build_range = memo$1('build_range', (input) => {\n    let tokens = get_tokens$1(input);\n    return flat_map(tokens, ({ type, value }) => {\n      if (type == 'char') return value;\n      let [ from, to ] = value;\n      let reverse = false;\n      if (from > to) {\n        [from, to] = [ to, from ];\n        reverse = true;\n      }\n      let result = by_charcode(range)(from, to);\n      if (reverse) result.reverse();\n      return result;\n    });\n  });\n\n  class Node {\n    constructor(data) {\n      this.prev = this.next = null;\n      this.data = data;\n    }\n  }\n\n  class Stack {\n    constructor(limit = 20) {\n      this._limit = limit;\n      this._size = 0;\n    }\n\n    push(data) {\n      if (this._size >= this._limit) {\n        this.root = this.root.next;\n        this.root.prev = null;\n      }\n\n      let node = new Node(data);\n\n      if (!this.root) {\n        this.root = this.tail = node;\n      } else {\n        node.prev = this.tail;\n        this.tail.next = node;\n        this.tail = node;\n      }\n\n      this._size++;\n    }\n\n    last(n = 1) {\n      let node = this.tail;\n      while (--n) {\n        if (!node.prev) break;\n        node = node.prev;\n      }\n      return node.data;\n    }\n  }\n\n  const { cos, sin, sqrt, pow, PI } = Math;\n  const DEG = PI / 180;\n\n  function polygon(option, fn) {\n    if (typeof arguments[0] == 'function') {\n      fn = option;\n      option = {};\n    }\n\n    if (!fn) {\n      fn = t => [ cos(t), sin(t) ];\n    }\n\n    let split = option.split || 120;\n    let scale = option.scale || 1;\n    let start = DEG * (option.start || 0);\n    let deg = option.deg ? (option.deg * DEG) : (PI / (split / 2));\n    let points = [];\n\n    for (let i = 0; i < split; ++i) {\n      let t = start + deg * i;\n      let [x, y] = fn(t);\n      points.push(\n        ((x * 50 * scale) + 50 + '% ') +\n        ((y * 50 * scale) + 50 + '%')\n      );\n    }\n\n    return option.type\n      ? `polygon(${ option.type }, ${ points.join(',') })`\n      : `polygon(${ points.join(',') })`;\n  }\n\n  function rotate(x, y, deg) {\n    let rad = DEG * deg;\n    return [\n      x * cos(rad) - y * sin(rad),\n      y * cos(rad) + x * sin(rad)\n    ];\n  }\n\n  const shapes =  {\n\n    circle() {\n      return 'circle(49%)';\n    },\n\n    triangle() {\n      return polygon({ split: 3, start: -90 }, t => [\n        cos(t) * 1.1,\n        sin(t) * 1.1 + .2\n      ]);\n    },\n\n    rhombus() {\n      return polygon({ split: 4 });\n    },\n\n    pentagon() {\n      return polygon({ split: 5, start: 54 });\n    },\n\n    hexgon() {\n      return polygon({ split: 6, start: 30 });\n    },\n\n    hexagon() {\n      return polygon({ split: 6, start: 30 });\n    },\n\n    heptagon() {\n      return polygon({ split: 7, start: -90 });\n    },\n\n    octagon() {\n      return polygon({ split: 8, start: 22.5 });\n    },\n\n    star() {\n      return polygon({ split: 5, start: 54, deg: 144 });\n    },\n\n    diamond() {\n      return 'polygon(50% 5%, 80% 50%, 50% 95%, 20% 50%)';\n    },\n\n    cross() {\n      return `polygon(\n      5% 35%,  35% 35%, 35% 5%,  65% 5%,\n      65% 35%, 95% 35%, 95% 65%, 65% 65%,\n      65% 95%, 35% 95%, 35% 65%, 5% 65%\n    )`;\n    },\n\n    clover(k = 3) {\n      k = clamp(k, 3, 5);\n      if (k == 4) k = 2;\n      return polygon({ split: 240 }, t => {\n        let x = cos(k * t) * cos(t);\n        let y = cos(k * t) * sin(t);\n        if (k == 3) x -= .2;\n        if (k == 2) {\n          x /= 1.1;\n          y /= 1.1;\n        }\n        return [x, y];\n      });\n    },\n\n    hypocycloid(k = 3) {\n      k = clamp(k, 3, 6);\n      let m = 1 - k;\n      return polygon({ scale: 1 / k  }, t => {\n        let x = m * cos(t) + cos(m * (t - PI));\n        let y = m * sin(t) + sin(m * (t - PI));\n        if (k == 3) {\n          x = x * 1.1 - .6;\n          y = y * 1.1;\n        }\n        return [x, y];\n      });\n    },\n\n    astroid() {\n      return shapes.hypocycloid(4);\n    },\n\n    infinity() {\n      return polygon(t => {\n        let a = .7 * sqrt(2) * cos(t);\n        let b = (pow(sin(t), 2) + 1);\n        return [\n          a / b,\n          a * sin(t) / b\n        ]\n      });\n    },\n\n    heart() {\n      return polygon(t => {\n        let x = .75 * pow(sin(t), 3);\n        let y =\n            cos(1 * t) * (13 / 18)\n          - cos(2 * t) * (5 / 18)\n          - cos(3 * t) / 18\n          - cos(4 * t) / 18;\n        return rotate(\n          x * 1.2,\n          (y + .2) * 1.1,\n          180\n        );\n      });\n    },\n\n    bean() {\n      return polygon(t => {\n        let [a, b] = [pow(sin(t), 3), pow(cos(t), 3)];\n        return rotate(\n          (a + b) * cos(t) * 1.3 - .45,\n          (a + b) * sin(t) * 1.3 - .45,\n          -90\n        );\n      });\n    },\n\n    bicorn() {\n      return polygon(t => rotate(\n        cos(t),\n        pow(sin(t), 2) / (2 + sin(t)) - .5,\n        180\n      ));\n    },\n\n    drop() {\n      return polygon(t => rotate(\n        sin(t),\n        (1 + sin(t)) * cos(t) / 1.4,\n        90\n      ));\n    },\n\n    pear() {\n      return polygon(t => [\n        sin(t),\n        (1 + sin(t)) * cos(t) / 1.4\n      ]);\n    },\n\n    fish() {\n      return polygon(t => [\n        cos(t) - pow(sin(t), 2) / sqrt(2),\n        sin(2 * t) / 2\n      ]);\n    },\n\n    whale() {\n      return polygon({ split: 240 }, t => {\n        let r = 3.4 * (pow(sin(t), 2) - .5) * cos(t);\n        return rotate(\n          cos(t) * r + .75,\n          sin(t) * r * 1.2,\n          180\n        );\n      });\n    },\n\n    bud(n = 3) {\n      n = clamp(n, 3, 10);\n      return polygon({ split: 240 }, t => [\n        ((1 + .2 * cos(n * t)) * cos(t)) * .8,\n        ((1 + .2 * cos(n * t)) * sin(t)) * .8\n      ]);\n    },\n\n    alien(...args) {\n      let [a = 1, b = 1, c = 1, d = 1, e = 1]\n        = args.map(n => clamp(n, 1, 9));\n      return polygon({ split: 480, type: 'evenodd' }, t => [\n        (cos(t * a) + cos(t * c) + cos(t * e)) * .31,\n        (sin(t * b) + sin(t * d) + sin(t)) * .31\n      ]);\n    }\n\n  };\n\n  function is_seperator(c, no_space) {\n    if (no_space) return /[,，]/.test(c);\n    else return /[,，\\s]/.test(c);\n  }\n\n  function skip_seperator(it, no_space) {\n    while (!it.end()) {\n      if (!is_seperator(it.curr(1), no_space)) break;\n      else it.next();\n    }\n  }\n\n  function parse$2(input, no_space = false) {\n    const it = iterator(input);\n    const result = [], stack = [];\n    let group = '';\n\n    while (!it.end()) {\n      let c = it.curr();\n      if (c === undefined) break;\n      if (c == '(') {\n        group += c;\n        stack.push(c);\n      }\n\n      else if (c == ')') {\n        group += c;\n        if (stack.length) {\n          stack.pop();\n        }\n      }\n\n      else if (stack.length) {\n        group += c;\n      }\n\n      else if (is_seperator(c, no_space)) {\n        result.push(group);\n        group = '';\n        skip_seperator(it, no_space);\n      }\n\n      else {\n        group += c;\n      }\n\n      it.next();\n    }\n\n    if (group) {\n      result.push(group);\n    }\n\n    return result;\n  }\n\n  const Expose = {\n\n    index({ count }) {\n      return _ => count;\n    },\n\n    row({ x }) {\n      return _ => x;\n    },\n\n    col({ y }) {\n      return _ => y;\n    },\n\n    depth({ z }) {\n      return _ => z;\n    },\n\n    size({ grid }) {\n      return _ => grid.count;\n    },\n\n    ['size-row']({ grid }) {\n      return _ => grid.x;\n    },\n\n    ['size-col']({ grid }) {\n      return _ => grid.y;\n    },\n\n    ['size-depth']({ grid }) {\n      return _ => grid.z;\n    },\n\n    id({ x, y, z }) {\n      return _ => cell_id(x, y, z);\n    },\n\n    n({ extra }) {\n      return _ => {\n        return extra ? extra[0] : '@n';\n      }\n    },\n\n    N({ extra }) {\n      return _ => {\n        return extra ? extra[1] : '@N';\n      }\n    },\n\n    repeat: (\n      make_sequence('')\n    ),\n\n    multiple: (\n      make_sequence(',')\n    ),\n\n    ['multiple-with-space']: (\n      make_sequence(' ')\n    ),\n\n    pick({ context }) {\n      return expand((...args) => {\n        return push_stack(context, 'last_pick', pick(args));\n      });\n    },\n\n    ['pick-n']({ context, extra, position }) {\n      let counter = 'pn-counter' + position;\n      return expand((...args) => {\n        if (!context[counter]) context[counter] = 0;\n        context[counter] += 1;\n        let max = args.length;\n        let [ idx ] = extra || [];\n        let pos = ((idx === undefined ? context[counter] : idx) - 1) % max;\n        let value = args[pos];\n        return push_stack(context, 'last_pick', value);\n      });\n    },\n\n    ['pick-d']({ context, extra, position }) {\n      let counter = 'pd-counter' + position;\n      let values = 'pd-values' + position;\n      return expand((...args) => {\n        if (!context[counter]) context[counter] = 0;\n        context[counter] += 1;\n        if (!context[values]) {\n          context[values] = shuffle(args);\n        }\n        let max = args.length;\n        let [ idx ] = extra || [];\n        let pos = ((idx === undefined ? context[counter] : idx) - 1) % max;\n        let value = context[values][pos];\n        return push_stack(context, 'last_pick', value);\n      });\n    },\n\n    ['last-pick']({ context }) {\n      return (n = 1) => {\n        let stack = context.last_pick;\n        return stack ? stack.last(n) : '';\n      };\n    },\n\n    rand({ context }) {\n      return (...args) => {\n        let transform_type = args.every(is_letter)\n          ? by_charcode\n          : by_unit;\n        let value = transform_type(rand).apply(null, args);\n        return push_stack(context, 'last_rand', value);\n      };\n    },\n\n    ['rand-int']({ context }) {\n      return (...args) => {\n        let transform_type = args.every(is_letter)\n          ? by_charcode\n          : by_unit;\n        let value = parseInt(\n          transform_type(rand).apply(null, args)\n        );\n        return push_stack(context, 'last_rand', value);\n      }\n    },\n\n    ['last-rand']({ context }) {\n      return (n = 1) => {\n        let stack = context.last_rand;\n        return stack ? stack.last(n) : '';\n      };\n    },\n\n    stripe() {\n      return (...input) => {\n        let colors = input.map(get_value);\n        let max = colors.length;\n        let default_count = 0;\n        let custom_sizes = [];\n        let prev;\n        if (!max) {\n          return '';\n        }\n        colors.forEach(step => {\n          let [_, size] = parse$2(step);\n          if (size !== undefined) custom_sizes.push(size);\n          else default_count += 1;\n        });\n        let default_size = custom_sizes.length\n          ? `(100% - ${custom_sizes.join(' - ')}) / ${default_count}`\n          : `100% / ${max}`;\n        return colors\n          .map((step, i) => {\n            if (custom_sizes.length) {\n              let [color, size] = parse$2(step);\n              let prefix = prev ? (prev + ' + ') : '';\n              prev = prefix + (size !== undefined ? size : default_size);\n              return `${color} 0 calc(${ prev })`\n            }\n            return `${step} 0 ${100 / max * (i + 1)}%`\n          })\n          .join(',');\n      }\n    },\n\n    calc() {\n      return value => calc(get_value(value));\n    },\n\n    hex() {\n      return value => parseInt(get_value(value)).toString(16);\n    },\n\n    svg: lazy(input => {\n      if (input === undefined) return '';\n      let svg = normalize_svg(get_value(input()).trim());\n      return create_svg_url(svg);\n    }),\n\n    ['svg-filter']: lazy(input => {\n      if (input === undefined) return '';\n      let id = unique_id('filter-');\n      let svg = normalize_svg(get_value(input()).trim())\n        .replace(\n          /<filter([\\s>])/,\n          `<filter id=\"${ id }\"$1`\n        );\n      return create_svg_url(svg, id);\n    }),\n\n    var() {\n      return value => `var(${ get_value(value) })`;\n    },\n\n    shape() {\n      return memo('shape-function', (type = '', ...args) => {\n        type = type.trim();\n        if (typeof shapes[type] === 'function') {\n          return shapes[type](args);\n        }\n        return '';\n      });\n    },\n\n  };\n\n  function make_sequence(c) {\n    return lazy((n, action) => {\n      if (!action || !n) return '';\n      let count = clamp(get_value(n()), 0, 65536);\n      return sequence(count, i => get_value(action(i + 1, count))).join(c);\n    });\n  }\n\n  function push_stack(context, name, value) {\n    if (!context[name]) context[name] = new Stack();\n    context[name].push(value);\n    return value;\n  }\n\n  var Func = alias_for(Expose, {\n    'm':  'multiple',\n    'ms': 'multiple-with-space',\n\n    'r':  'rand',\n    'ri': 'rand-int',\n    'lr': 'last-rand',\n\n    'p':  'pick',\n    'pn': 'pick-n',\n    'pd': 'pick-d',\n    'lp': 'last-pick',\n\n    'rep': 'repeat',\n\n    'i':  'index',\n    'x':  'row',\n    'y':  'col',\n    'z':  'depth',\n\n    's':  'size',\n    'sx': 'size-row',\n    'sy': 'size-col',\n    'sz': 'size-depth',\n\n    // legacy names\n    'size-x': 'size-row',\n    'size-y': 'size-col',\n    'size-z': 'size-depth',\n    'multi': 'multiple',\n    'pick-by-turn': 'pick-n',\n    'max-row': 'size-row',\n    'max-col': 'size-col',\n\n    // error prone\n    'stripes': 'stripe',\n    'strip':   'stripe',\n  });\n\n  let all = [];\n\n  function get_props(arg) {\n    if (!all.length) {\n      let props = new Set();\n      for (let n in document.head.style) {\n        if (!n.startsWith('-')) {\n          props.add(n.replace(/[A-Z]/g, '-$&').toLowerCase());\n        }\n      }\n      if (!props.has('grid-gap')) {\n        props.add('grid-gap');\n      }\n      all = Array.from(props);\n    }\n    return (arg && arg.test)\n      ? all.filter(n => arg.test(n))\n      : all;\n  }\n\n  function build_mapping(prefix) {\n    let reg = new RegExp(`\\\\-?${ prefix }\\\\-?`);\n    return get_props(reg)\n      .map(n => n.replace(reg, ''))\n      .reduce((obj, n) => { return obj[n] = n, obj }, {});\n  }\n\n  const props_webkit_mapping = build_mapping('webkit');\n  const props_moz_mapping = build_mapping('moz');\n\n  function prefixer(prop, rule) {\n    if (props_webkit_mapping[prop]) {\n      return `-webkit-${ rule } ${ rule }`;\n    }\n    else if (props_moz_mapping[prop]) {\n      return `-moz-${ rule } ${ rule }`;\n    }\n    return rule;\n  }\n\n  const presets = {\n\n   '4a0': [ 1682, 2378 ],\n   '2a0': [ 1189, 1682 ],\n    a0:   [ 841, 1189 ],\n    a1:   [ 594, 841 ],\n    a2:   [ 420, 594 ],\n    a3:   [ 297, 420 ],\n    a4:   [ 210, 297 ],\n    a5:   [ 148, 210 ],\n    a6:   [ 105, 148 ],\n    a7:   [ 74, 105 ],\n    a8:   [ 52, 74 ],\n    a9:   [ 37, 52 ],\n    a10:  [ 26, 37 ],\n\n    b0:  [ 1000, 1414 ],\n    b1:  [ 707, 1000 ],\n    b2:  [ 500, 707 ],\n    b3:  [ 353, 500 ],\n    b4:  [ 250, 353 ],\n    b5:  [ 176, 250 ],\n    b6:  [ 125, 176 ],\n    b7:  [ 88, 125 ],\n    b8:  [ 62, 88 ],\n    b9:  [ 44, 62 ],\n    b10: [ 31, 44 ],\n    b11: [ 22, 32 ],\n    b12: [ 16, 22 ],\n\n    c0:  [ 917, 1297 ],\n    c1:  [ 648, 917 ],\n    c2:  [ 458, 648 ],\n    c3:  [ 324, 458 ],\n    c4:  [ 229, 324 ],\n    c5:  [ 162, 229 ],\n    c6:  [ 114, 162 ],\n    c7:  [ 81, 114 ],\n    c8:  [ 57, 81 ],\n    c9:  [ 40, 57 ],\n    c10: [ 28, 40 ],\n    c11: [ 22, 32 ],\n    c12: [ 16, 22 ],\n\n    d0: [ 764, 1064 ],\n    d1: [ 532, 760 ],\n    d2: [ 380, 528 ],\n    d3: [ 264, 376 ],\n    d4: [ 188, 260 ],\n    d5: [ 130, 184 ],\n    d6: [ 92, 126 ],\n\n    letter:         [ 216, 279 ],\n    legal:          [ 216, 356 ],\n    'junior-legal': [ 203, 127 ],\n    ledger:         [ 279, 432 ],\n    tabloid:        [ 279, 432 ],\n    executive:      [ 190, 254 ],\n\n    postcard:        [ 100, 148 ],\n    'business-card': [ 54, 90 ],\n\n    poster: [ 390, 540 ],\n  };\n\n  const modes = {\n    portrait: 'p',\n    pt: 'p',\n    p: 'p',\n\n    landscape: 'l',\n    ls: 'l',\n    l: 'l',\n  };\n\n  const unit = 'mm';\n\n  function get_preset(name, mode) {\n    name = String(name).toLowerCase();\n\n    // Default to landscape mode\n    let [h, w] = presets[name] || [];\n\n    if (modes[mode] == 'p') {\n      [w, h] = [h, w];\n    }\n\n    return [w, h].map(n => n + unit);\n  }\n\n  function is_preset(name) {\n    return !!presets[name];\n  }\n\n  var Property = {\n\n    ['@size'](value, { is_special_selector }) {\n      let [w, h = w] = parse$2(value);\n      if (is_preset(w)) {\n        [w, h] = get_preset(w, h);\n      }\n      return `\n      width: ${ w };\n      height: ${ h };\n      ${ is_special_selector ? '' : `\n        --internal-cell-width: ${ w };\n        --internal-cell-height: ${ h };\n      `}\n    `;\n    },\n\n    ['@min-size'](value) {\n      let [w, h = w] = parse$2(value);\n      return `min-width: ${ w }; min-height: ${ h };`;\n    },\n\n    ['@max-size'](value) {\n      let [w, h = w] = parse$2(value);\n      return `max-width: ${ w }; max-height: ${ h };`;\n    },\n\n    ['@place-cell']: (() => {\n      let map_left_right = {\n        'center': '50%', '0': '0%',\n        'left': '0%', 'right': '100%',\n        'top': '50%', 'bottom': '50%'\n      };\n      let map_top_bottom = {\n        'center': '50%', '0': '0%',\n        'top': '0%', 'bottom': '100%',\n        'left': '50%', 'right': '50%',\n      };\n\n      return value => {\n        let [left, top = '50%'] = parse$2(value);\n        left = map_left_right[left] || left;\n        top = map_top_bottom[top] || top;\n        const cw = 'var(--internal-cell-width, 25%)';\n        const ch = 'var(--internal-cell-height, 25%)';\n        return `\n        position: absolute;\n        left: ${ left };\n        top: ${ top };\n        width: ${ cw };\n        height: ${ ch };\n        margin-left: calc(${ cw } / -2) !important;\n        margin-top: calc(${ ch } / -2) !important;\n        grid-area: unset !important;\n      `;\n      }\n    })(),\n\n    ['@grid'](value, options) {\n      let [grid, ...size] = value.split('/').map(s => s.trim());\n      size = size.join(' / ');\n      return {\n        grid: parse_grid(grid),\n        size: size ? this['@size'](size, options) : ''\n      };\n    },\n\n    ['@shape']: memo$1('shape-property', value => {\n      let [type, ...args] = parse$2(value);\n      let prop = 'clip-path';\n      if (!shapes[type]) return '';\n      let rules = `${ prop }: ${ shapes[type].apply(null, args) };`;\n      return prefixer(prop, rules) + 'overflow: hidden;';\n    }),\n\n    ['@use'](rules) {\n      if (rules.length > 2) {\n        return rules;\n      }\n    }\n\n  };\n\n  function build_expr(expr) {\n    return n => String(expr)\n      .replace(/(\\d+)(n)/g, '$1*' + n)\n      .replace(/n/g, n);\n  }\n\n  function nth(input, curr, max) {\n    let expr = build_expr(input);\n    for (let i = 0; i <= max; ++i) {\n      if (calc(expr(i)) == curr) return true;\n    }\n  }\n\n  const is$1 = {\n    even: n => !!(n % 2),\n    odd:  n => !(n % 2)\n  };\n\n  function even_or_odd(expr) {\n    return /^(even|odd)$/.test(expr);\n  }\n\n  var Selector = {\n\n    at({ x, y }) {\n      return (x1, y1) => (x == x1 && y == y1);\n    },\n\n    nth({ count, grid }) {\n      return (...exprs) => exprs.some(expr =>\n        even_or_odd(expr)\n          ? is$1[expr](count - 1)\n          : nth(expr, count, grid.count)\n      );\n    },\n\n    row({ x, grid }) {\n      return (...exprs) => exprs.some(expr =>\n        even_or_odd(expr)\n          ? is$1[expr](x - 1)\n          : nth(expr, x, grid.x)\n      );\n    },\n\n    col({ y, grid }) {\n      return (...exprs) => exprs.some(expr =>\n        even_or_odd(expr)\n          ? is$1[expr](y - 1)\n          : nth(expr, y, grid.y)\n      );\n    },\n\n    even({ count }) {\n      return _ => is$1.even(count - 1);\n    },\n\n    odd({ count }) {\n      return _ => is$1.odd(count - 1);\n    },\n\n    random() {\n      return (ratio = .5) => {\n        if (ratio >= 1 && ratio <= 0) ratio = .5;\n        return Math.random() < ratio;\n      }\n    }\n\n  };\n\n  // Expose all Math functions and constants.\n  const methods = Object.getOwnPropertyNames(Math);\n\n  var MathFunc = methods.reduce((expose, n) => {\n    expose[n] = () => (...args) => {\n      args = args.map(get_value);\n      if (typeof Math[n] === 'number') return Math[n];\n      return Math[n].apply(null, args.map(calc));\n    };\n    return expose;\n  }, {});\n\n  function is_host_selector(s) {\n    return /^\\:(host|doodle)/.test(s);\n  }\n\n  function is_parent_selector(s) {\n    return /^\\:(container|parent)/.test(s);\n  }\n\n  function is_special_selector(s) {\n    return is_host_selector(s) || is_parent_selector(s);\n  }\n\n  function is_nil(s) {\n    return s === undefined || s === null;\n  }\n\n  class Rules {\n\n    constructor(tokens) {\n      this.tokens = tokens;\n      this.rules = {};\n      this.props = {};\n      this.keyframes = {};\n      this.grid = null;\n      this.is_grid_defined = false;\n      this.coords = [];\n      this.reset();\n    }\n\n    reset() {\n      this.styles = {\n        host: '',\n        container: '',\n        cells: '',\n        keyframes: ''\n      };\n      this.coords = [];\n      for (let key in this.rules) {\n        if (key.startsWith('#cell')) {\n          delete this.rules[key];\n        }\n      }\n    }\n\n    add_rule(selector, rule) {\n      let rules = this.rules[selector];\n      if (!rules) {\n        rules = this.rules[selector] = [];\n      }\n\n      rules.push.apply(rules, make_array(rule));\n    }\n\n    pick_func(name) {\n      return Func[name] || MathFunc[name];\n    }\n\n    apply_func(fn, coords, args) {\n      let _fn = fn(...make_array(coords));\n\n      let input = [];\n      args.forEach(arg => {\n        if (!arg.cluster && typeof arg.value == 'string') {\n          input.push(...parse$2(arg.value, true));\n        } else {\n          if (typeof arg == 'function') {\n            input.push(arg);\n          } else if (arg && arg.value) {\n            input.push(arg.value);\n          }\n        }\n      });\n\n      input = remove_empty_values(input);\n      let result = _fn(...make_array(input));\n      return result;\n    }\n\n    compose_aname(...args) {\n      return args.join('-');\n    }\n\n    compose_selector({ x, y, z}, pseudo = '') {\n      return `#${ cell_id(x, y, z) }${ pseudo }`;\n    }\n\n    compose_argument(argument, coords, extra = []) {\n      let result = argument.map(arg => {\n        if (arg.type == 'text') {\n          return arg.value;\n        }\n        else if (arg.type == 'func') {\n          let fn = this.pick_func(arg.name.substr(1));\n          if (fn) {\n            coords.extra = extra;\n            coords.position = arg.position;\n            let args = arg.arguments.map(n => {\n              return fn.lazy\n                ? (...extra) => this.compose_argument(n, coords, extra)\n                : this.compose_argument(n, coords, extra);\n            });\n            return this.apply_func(fn, coords, args)\n          }\n        }\n      });\n\n      return {\n        cluster: argument.cluster,\n        value: (result.length >= 2 ? ({ value: result.join('') }) : result[0])\n      }\n    }\n\n    compose_value(value, coords) {\n      if (!value || !value.reduce) return '';\n      let ret = value.reduce((result, val) => {\n        switch (val.type) {\n          case 'text': {\n            result += val.value;\n            break;\n          }\n          case 'func': {\n            let fname = val.name.substr(1);\n            let fn = this.pick_func(fname);\n            if (fn) {\n              coords.position = val.position;\n              let args = val.arguments.map(arg => {\n                return fn.lazy\n                  ? (...extra) => this.compose_argument(arg, coords, extra)\n                  : this.compose_argument(arg, coords);\n              });\n\n              let output = this.apply_func(fn, coords, args);\n\n              if (!is_nil(output)) {\n                result += output;\n              }\n            }\n          }\n        }\n        return result;\n      }, '');\n\n      return ret;\n    }\n\n    compose_rule(token, _coords, selector) {\n      let coords = Object.assign({}, _coords);\n      let prop = token.property;\n      let value_group = token.value.reduce((ret, v) => {\n        let composed = this.compose_value(v, coords);\n        if (composed) ret.push(composed);\n        return ret;\n      }, []);\n\n      let value = value_group.join(', ');\n\n      if (/^animation(\\-name)?$/.test(prop)) {\n        this.props.has_animation = true;\n        if (coords.count > 1) {\n          let { count } = coords;\n          switch (prop) {\n            case 'animation-name': {\n              value = value_group\n                .map(n => this.compose_aname(n, count))\n                .join(', ');\n              break;\n            }\n            case 'animation': {\n              value = value_group\n                .map(n => {\n                  let group = (n || '').split(/\\s+/);\n                  group[0] = this.compose_aname(group[0], count);\n                  return group.join(' ');\n                })\n                .join(', ');\n            }\n          }\n        }\n      }\n\n      if (prop == 'content') {\n        if (!/[\"']|^none$|^(var|counter|counters|attr)\\(/.test(value)) {\n          value = `'${ value }'`;\n        }\n      }\n\n      if (prop == 'transition') {\n        this.props.has_transition = true;\n      }\n\n      let rule = `${ prop }: ${ value };`;\n      rule = prefixer(prop, rule);\n\n      if (prop == 'clip-path') {\n        // fix clip bug\n        rule += ';overflow: hidden;';\n      }\n\n      if (prop == 'width' || prop == 'height') {\n        if (!is_special_selector(selector)) {\n          rule += `--internal-cell-${ prop }: ${ value };`;\n        }\n      }\n\n      if (Property[prop]) {\n        let transformed = Property[prop](value, {\n          is_special_selector: is_special_selector(selector)\n        });\n        switch (prop) {\n          case '@grid': {\n            if (is_host_selector(selector)) {\n              this.grid = transformed.grid;\n              rule = transformed.size || '';\n            } else {\n              rule = '';            if (!this.is_grid_defined) {\n                transformed = Property[prop](value, {\n                  is_special_selector: true\n                });\n                this.grid = transformed.grid;\n                this.add_rule(':host', transformed.size || '');\n              }\n            }\n            this.is_grid_defined = true;\n            break;\n          }\n          case '@place-cell': {\n            if (!is_host_selector(selector)) {\n              rule = transformed;\n            }\n          }\n          case '@use': {\n            if (token.value.length) {\n              this.compose(coords, token.value);\n            }\n            rule = Property[prop](token.value);\n          }\n          default: {\n            rule = transformed;\n          }\n        }\n      }\n\n      return rule;\n    }\n\n    compose(coords, tokens, initial) {\n      this.coords.push(coords);\n      (tokens || this.tokens).forEach((token, i) => {\n        if (token.skip) return false;\n        if (initial && this.grid) return false;\n\n        switch (token.type) {\n          case 'rule':\n            this.add_rule(\n              this.compose_selector(coords),\n              this.compose_rule(token, coords)\n            );\n            break;\n\n          case 'pseudo': {\n            if (token.selector.startsWith(':doodle')) {\n              token.selector = token.selector.replace(/^\\:+doodle/, ':host');\n            }\n            let special = is_special_selector(token.selector);\n            if (special) {\n              token.skip = true;\n            }\n            token.selector.split(',').forEach(selector => {\n              let pseudo = token.styles.map(s =>\n                this.compose_rule(s, coords, selector)\n              );\n              let composed = special\n                ? selector\n                : this.compose_selector(coords, selector);\n              this.add_rule(composed, pseudo);\n            });\n\n            break;\n          }\n\n          case 'cond': {\n            let fn = Selector[token.name.substr(1)];\n            if (fn) {\n              let args = token.arguments.map(arg => {\n                return this.compose_argument(arg, coords);\n              });\n              let result = this.apply_func(fn, coords, args);\n              if (result) {\n                this.compose(coords, token.styles);\n              }\n            }\n            break;\n          }\n\n          case 'keyframes': {\n            if (!this.keyframes[token.name]) {\n              this.keyframes[token.name] = coords => `\n              ${ join(token.steps.map(step => `\n                ${ step.name } {\n                  ${ join(\n                    step.styles.map(s => this.compose_rule(s, coords))\n                  )}\n                }\n              `)) }\n            `;\n            }\n          }\n        }\n      });\n    }\n\n    output() {\n      Object.keys(this.rules).forEach((selector, i) => {\n        if (is_parent_selector(selector)) {\n          this.styles.container += `\n          .container {\n            ${ join(this.rules[selector]) }\n          }\n        `;\n        } else {\n          let target = is_host_selector(selector) ? 'host' : 'cells';\n          this.styles[target] += `\n          ${ selector } {\n            ${ join(this.rules[selector]) }\n          }\n        `;\n        }\n      });\n\n      let keyframes = Object.keys(this.keyframes);\n      this.coords.forEach((coords, i) => {\n        keyframes.forEach(name => {\n          let aname = this.compose_aname(name, coords.count);\n          this.styles.keyframes += `\n          ${ maybe(i == 0,\n            `@keyframes ${ name } {\n              ${ this.keyframes[name](coords) }\n            }`\n          )}\n          @keyframes ${ aname } {\n            ${ this.keyframes[name](coords) }\n          }\n        `;\n        });\n      });\n\n      return {\n        props: this.props,\n        styles: this.styles,\n        grid: this.grid\n      }\n    }\n  }\n\n  function generator(tokens, grid_size) {\n    let rules = new Rules(tokens);\n    let context = {};\n\n    rules.compose({\n      x: 1, y: 1, z: 1, count: 1, context: {},\n      grid: { x: 1, y: 1, z: 1, count: 1 }\n    }, null, true);\n\n    let { grid } = rules.output();\n    if (grid) grid_size = grid;\n    rules.reset();\n\n    if (grid_size.z == 1) {\n      for (let x = 1, count = 0; x <= grid_size.x; ++x) {\n        for (let y = 1; y <= grid_size.y; ++y) {\n          rules.compose({\n            x, y, z: 1,\n            count: ++count, grid: grid_size, context\n          });\n        }\n      }\n    }\n    else {\n      for (let z = 1, count = 0; z <= grid_size.z; ++z) {\n        rules.compose({\n          x: 1, y: 1, z,\n          count: ++count, grid: grid_size, context\n        });\n      }\n    }\n\n    return rules.output();\n  }\n\n  class Doodle extends HTMLElement {\n    constructor() {\n      super();\n      this.doodle = this.attachShadow({ mode: 'open' });\n      this.extra = {\n        get_custom_property_value: this.get_custom_property_value.bind(this)\n      };\n    }\n    load(again) {\n      let compiled;\n      let use = this.getAttribute('use') || '';\n      if (use) use = `@use:${ use };`;\n      if (!this.innerHTML.trim() && !use) return false;\n      try {\n        let parsed = parse$1(use + this.innerHTML, this.extra);\n        this.grid_size = parse_grid(this.getAttribute('grid'));\n        compiled = generator(parsed, this.grid_size);\n        compiled.grid && (this.grid_size = compiled.grid);\n        this.build_grid(compiled);\n      } catch (e) {\n        this.innerHTML = '';\n        console.error(e && e.message || 'Error in css-doodle.');\n      }\n      if (!again && this.hasAttribute('click-to-update')) {\n        this.addEventListener('click', e => this.update());\n      }\n    }\n    connectedCallback(again) {\n      if (/^(complete|interactive|loaded)$/.test(document.readyState)) {\n        this.load();\n      } else {\n        setTimeout(() => this.load(again));\n      }\n    }\n\n    get_custom_property_value(name) {\n      return getComputedStyle(this).getPropertyValue(name)\n        .trim()\n        .replace(/^\\(|\\)$/g, '');\n    }\n\n    cell(x, y, z) {\n      let cell = document.createElement('div');\n      cell.id = cell_id(x, y, z);\n      return cell;\n    }\n\n    build_grid(compiled) {\n      const { has_transition, has_animation } = compiled.props;\n      const { keyframes, host, container, cells } = compiled.styles;\n\n      this.doodle.innerHTML = `\n      <style>\n        ${ this.style_basic() }\n      </style>\n      <style class=\"style-keyframes\">\n        ${ keyframes }\n      </style>\n      <style class=\"style-container\">\n        ${ this.style_size() }\n        ${ host }\n        ${ container }\n      </style>\n      <style class=\"style-cells\">\n        ${ (has_transition || has_animation) ? '' : cells }\n      </style>\n      <div class=\"container\"></div>\n    `;\n\n      this.doodle.querySelector('.container')\n        .appendChild(this.html_cells());\n\n      if (has_transition || has_animation) {\n        setTimeout(() => {\n          this.set_style('.style-cells', cells);\n        }, 50);\n      }\n    }\n\n    inherit_props(p) {\n      return get_props(/grid/)\n        .map(n => `${ n }: inherit;`)\n        .join('');\n    }\n\n    style_basic() {\n      return `\n      * {\n        box-sizing: border-box;\n      }\n      *::after, *::before {\n        box-sizing: inherit;\n      }\n      :host {\n        display: block;\n        visibility: visible;\n        width: auto;\n        height: auto;\n      }\n      .container {\n        position: relative;\n        width: 100%;\n        height: 100%;\n        display: grid;\n        ${ this.inherit_props() }\n      }\n      .container div:empty {\n        position: relative;\n        line-height: 1;\n        display: grid;\n        place-items: center;\n      }\n    `;\n    }\n\n    style_size() {\n      let { x, y } = this.grid_size;\n      return `\n      :host {\n        grid-template-rows: repeat(${ x }, 1fr);\n        grid-template-columns: repeat(${ y }, 1fr);\n      }\n    `;\n    }\n\n    html_cells() {\n      let { x, y, z } = this.grid_size;\n      let root = document.createDocumentFragment();\n      if (z == 1) {\n        for (let i = 1; i <= x; ++i) {\n          for (let j = 1; j <= y; ++j) {\n            root.appendChild(this.cell(i, j, 1));\n          }\n        }\n      }\n      else {\n        let temp = null;\n        for (let i = 1; i <= z; ++i) {\n          let cell = this.cell(1, 1, i);\n          (temp || root).appendChild(cell);\n          temp = cell;\n        }\n        temp = null;\n      }\n      return root;\n    }\n\n    set_style(selector, styles) {\n      const el = this.shadowRoot.querySelector(selector);\n      el && (el.styleSheet\n        ? (el.styleSheet.cssText = styles )\n        : (el.innerHTML = styles));\n    }\n\n    update(styles) {\n      let use = this.getAttribute('use') || '';\n      if (use) use = `@use:${ use };`;\n\n      if (!styles) styles = this.innerHTML;\n      this.innerHTML = styles;\n\n      if (!this.grid_size) {\n        this.grid_size = parse_grid(this.getAttribute('grid'));\n      }\n\n      const compiled = generator(parse$1(use + styles, this.extra), this.grid_size);\n\n      if (compiled.grid) {\n        let { x, y, z } = compiled.grid;\n        let { x: gx, y: gy, z: gz } = this.grid_size;\n        if (gx !== x || gy !== y || gz !== z) {\n          Object.assign(this.grid_size, compiled.grid);\n          return this.build_grid(compiled);\n        }\n        Object.assign(this.grid_size, compiled.grid);\n      }\n\n      else {\n        let grid = parse_grid(this.getAttribute('grid'));\n        let { x, y, z } = grid;\n        let { x: gx, y: gy, z: gz } = this.grid_size;\n        if (gx !== x || gy !== y || gz !== z) {\n          Object.assign(this.grid_size, grid);\n          return this.build_grid(\n            generator(parse$1(use + styles, this.extra), this.grid_size)\n          );\n        }\n      }\n\n      this.set_style('.style-keyframes',\n        compiled.styles.keyframes\n      );\n\n      if (compiled.props.has_animation) {\n        this.set_style('.style-cells', '');\n        this.set_style('.style-container', '');\n      }\n\n      setTimeout(() => {\n        this.set_style('.style-container',\n            this.style_size()\n          + compiled.styles.host\n          + compiled.styles.container\n        );\n        this.set_style('.style-cells',\n          compiled.styles.cells\n        );\n      });\n    }\n\n    get grid() {\n      return Object.assign({}, this.grid_size);\n    }\n\n    set grid(grid) {\n      this.setAttribute('grid', grid);\n      this.connectedCallback(true);\n    }\n\n    get use() {\n      return this.getAttribute('use');\n    }\n\n    set use(use) {\n      this.setAttribute('use', use);\n      this.connectedCallback(true);\n    }\n\n    static get observedAttributes() {\n      return ['grid', 'use'];\n    }\n\n    attributeChangedCallback(name, old_val, new_val) {\n      if (old_val == new_val) {\n        return false;\n      }\n      if (name == 'grid' && old_val) {\n        this.grid = new_val;\n      }\n      if (name == 'use' && old_val) {\n        this.use = new_val;\n      }\n    }\n  }\n\n  if (!customElements.get('css-doodle')) {\n    customElements.define('css-doodle', Doodle);\n  }\n\n  function CSSDoodle(input, ...vars) {\n    let get_value = v =>\n      (v !== undefined && v !== null) ? v : '';\n    let rules = input.reduce((s, c, i) => s + c + get_value(vars[i]), '');\n    let doodle = document.createElement('css-doodle');\n    if (doodle.update) {\n      doodle.update(rules);\n    }\n    return doodle;\n  }\n\n  return CSSDoodle;\n\n})));\n"]},"metadata":{},"sourceType":"script"}